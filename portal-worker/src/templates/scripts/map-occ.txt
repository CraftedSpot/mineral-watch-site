        // ============================================
        // OCC Filings Functions for Map Modal
        // ============================================

        // State tracking for OCC filing processing
        const occProcessingStates = {};
        const OCC_POLL_INTERVAL = 5000;
        const OCC_MAX_POLL_DURATION = 5 * 60 * 1000;

        // Toggle OCC filings accordion
        function toggleMapOccFilings() {
            const content = document.getElementById('map-occ-content');
            const arrow = document.getElementById('map-occ-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // getMatchReasonStyle() and getMatchReasonLabel() are now defined in shared utilities at top of script

        async function mapUnlinkProperty(linkId, wellId) {
            if (!confirm('Remove this property link?')) return;
            try {
                const res = await fetch(`/api/property-well-link/${linkId}`, { method: 'DELETE', credentials: 'include' });
                if (res.ok) expandWellCard(wellId, true);
                else showMapToast('Failed to unlink', 'error');
            } catch (e) { showMapToast('Error: ' + e.message, 'error'); }
        }
        async function mapRelinkProperty(linkId, wellId) {
            try {
                const res = await fetch(`/api/property-well-link/${linkId}`, { method: 'PATCH', credentials: 'include' });
                if (res.ok) expandWellCard(wellId, true);
                else showMapToast('Failed to relink', 'error');
            } catch (e) { showMapToast('Error: ' + e.message, 'error'); }
        }

        // Toggle linked properties accordion
        function toggleMapLinkedProperties() {
            const content = document.getElementById('map-linked-props-content');
            const arrow = document.getElementById('map-linked-props-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // Toggle linked documents accordion
        function toggleMapLinkedDocs() {
            const content = document.getElementById('map-linked-docs-content');
            const arrow = document.getElementById('map-linked-docs-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // Toggle Well Records accordion
        function toggleMapWellRecords() {
            const content = document.getElementById('map-well-records-content');
            const arrow = document.getElementById('map-well-records-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // ============================================
        // Well Records Functions (Completion Reports)
        // ============================================

        // State tracking for completion report processing
        const mapCompletionProcessingStates = {};
        const mapAnalyzedCompletionsCache = {};

        // Load completion reports for a well
        async function loadMapCompletionReports(apiNumber) {
            console.log('[MapWellRecords] Loading completion reports for API:', apiNumber);
            const countBadge = document.getElementById('wellModalWellRecordsCount');
            const reportsContainer = document.getElementById('wellModalCompletionReports');

            try {
                const response = await fetch(`/api/wells/${apiNumber}/completion-reports`, { credentials: 'include' });
                const data = await response.json();
                const completionReports = data.completionReports || [];

                console.log('[MapWellRecords] Found', completionReports.length, 'completion reports');

                // Update count badge (remove loading class, show count)
                countBadge.className = '';
                countBadge.style.cssText = 'background: #e5e7eb; padding: 2px 8px; border-radius: 12px; font-size: 12px;';
                countBadge.textContent = completionReports.length;

                if (completionReports.length === 0) {
                    reportsContainer.innerHTML = '<div style="color: #6b7280; font-size: 13px; font-style: italic; padding: 8px 0;">No completion reports found</div>';
                    return;
                }

                // Sort by effective date (newest first) - same as dashboard
                completionReports.sort((a, b) => {
                    const dateA = parseCompletionDate(a.effectiveDate);
                    const dateB = parseCompletionDate(b.effectiveDate);
                    return dateB - dateA;
                });

                // Render completion reports
                const html = completionReports.map((report, idx) => {
                    const isCurrent = idx === 0; // Most recent is "current"
                    return renderMapCompletionReport(report, apiNumber, isCurrent);
                }).join('');

                reportsContainer.innerHTML = html;

            } catch (error) {
                console.error('[MapWellRecords] Error loading completion reports:', error);
                countBadge.className = '';
                countBadge.style.cssText = 'background: #fecaca; padding: 2px 8px; border-radius: 12px; font-size: 12px; color: #dc2626;';
                countBadge.textContent = '!';
                reportsContainer.innerHTML = '<div style="color: #ef4444; font-size: 13px; padding: 8px 0;">Error loading completion reports</div>';
            }
        }

        // Render a completion report item
        function renderMapCompletionReport(report, apiNumber, isCurrent) {
            const isRecompletion = report.formType === '1002C';
            const typeClass = isRecompletion ? 'recompletion' : 'completion';
            const typeLabel = isRecompletion ? 'RECOMPLETION 1002C' : 'COMPLETION 1002A';
            const dateDisplay = formatCompletionDate(report.effectiveDate);
            const buttonId = `map-completion-btn-${report.entryId}`;
            const currentBadge = isCurrent ? '<span class="completion-current-badge">Current</span>' : '';

            // Check client-side cache first
            const cached = mapAnalyzedCompletionsCache[report.entryId];

            // Render action button based on status
            let actionButton = '';
            if (cached && cached.documentId) {
                actionButton = `
                    <button class="occ-reanalyze-btn"
                            onclick="analyzeMapCompletion('${apiNumber}', ${report.entryId}, this, true)"
                            title="Re-process this document">Re-analyze</button>
                    <button class="occ-view-doc-btn" onclick="openMapDocumentDetail('${cached.documentId}')" title="View analyzed document">View Doc ↗</button>`;
            } else switch (report.status) {
                case 'available':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${report.entryId}, this)">
                            Analyze
                        </button>`;
                    break;
                case 'fetching':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn fetching" disabled>
                            <span class="spinner-sm"></span>Analyzing...
                        </button>`;
                    break;
                case 'fetched':
                case 'processed':
                    actionButton = `
                        <button class="occ-reanalyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${report.entryId}, this, true)"
                                title="Re-process this document">Re-analyze</button>
                        ${report.documentId ? `<button class="occ-view-doc-btn" onclick="openMapDocumentDetail('${report.documentId}')" title="View analyzed document">View Doc ↗</button>` : ''}`;
                    break;
                case 'error':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn error"
                                onclick="analyzeMapCompletion('${apiNumber}', ${report.entryId}, this)"
                                title="${escapeHtml(report.errorMessage || 'Error occurred')}">
                            Retry
                        </button>`;
                    break;
                default:
                    actionButton = '<span style="color: #888; font-size: 12px;">—</span>';
            }

            return `
                <div class="completion-report-item${isCurrent ? ' is-current' : ''}">
                    <div class="completion-report-main">
                        <div>
                            <span class="completion-report-type ${typeClass}">${typeLabel}</span>
                            ${currentBadge}
                            <span class="completion-report-location">${escapeHtml(report.location || '')}</span>
                        </div>
                        <div class="completion-report-details">
                            ${report.county ? `<span>${escapeHtml(report.county)} County</span>` : ''}
                            ${report.wellName ? `<span>• ${escapeHtml(report.wellName)}</span>` : ''}
                            ${report.pun ? `<span class="completion-report-pun">PUN: ${escapeHtml(report.pun)}</span>` : ''}
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div class="occ-filing-actions">
                            ${actionButton}
                        </div>
                        <div class="completion-report-date">${dateDisplay}</div>
                    </div>
                </div>
            `;
        }

        // Analyze completion report
        async function analyzeMapCompletion(apiNumber, entryId, buttonEl, force = false) {
            console.log(`[MapWellRecords] ${force ? 'Re-analyzing' : 'Analyzing'} ${apiNumber} entryId ${entryId}`);

            const parentContainer = buttonEl.closest('.occ-filing-actions');
            if (!parentContainer) return;

            // Update to fetching state
            mapCompletionProcessingStates[entryId] = { status: 'fetching', buttonEl };
            parentContainer.innerHTML = `
                <button class="completion-analyze-btn fetching" disabled>
                    <span class="spinner-sm"></span>${force ? 'Re-analyzing...' : 'Fetching...'}
                </button>`;

            try {
                const response = await fetch('/api/occ/fetch-1002a', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ apiNumber, entryId, force })
                });

                const result = await response.json();

                if (response.status === 401) {
                    parentContainer.innerHTML = `
                        <button class="completion-analyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)">
                            Analyze
                        </button>`;
                    showMapToast('Please log in to analyze completion reports', 'error');
                    return;
                }

                if (result.alreadyProcessed) {
                    console.log(`[MapWellRecords] Already processed: ${result.documentId}`);
                    mapAnalyzedCompletionsCache[entryId] = { documentId: result.documentId };
                    parentContainer.innerHTML = `
                        <button class="occ-reanalyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this, true)"
                                title="Re-process this document">Re-analyze</button>
                        <button class="occ-view-doc-btn" onclick="openMapDocumentDetail('${result.documentId}')" title="View analyzed document">View Doc ↗</button>`;
                } else if (result.success) {
                    const docId = result.document.id;
                    const docStatus = result.document.status || 'pending';
                    console.log(`[MapWellRecords] Successfully queued: ${docId}, status: ${docStatus}`);

                    // Check for completion - handle both 'complete' and 'processed' statuses
                    if (docStatus === 'complete' || docStatus === 'processed') {
                        mapAnalyzedCompletionsCache[entryId] = { documentId: docId };
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this, true)"
                                    title="Re-process this document">Re-analyze</button>
                            <button class="occ-view-doc-btn" onclick="openMapDocumentDetail('${docId}')" title="View analyzed document">View Doc ↗</button>`;
                        showMapToast('Completion report analyzed!', 'success');
                        // Refresh the completion reports list to show updated PUN
                        loadMapCompletionReports(apiNumber);
                    } else {
                        // Start polling
                        parentContainer.innerHTML = `
                            <button class="completion-analyze-btn ${docStatus === 'processing' ? 'processing' : 'queued'}" disabled>
                                <span class="spinner-sm"></span>${docStatus === 'processing' ? 'Processing...' : 'Queued...'}
                            </button>`;
                        startMapCompletionPolling(entryId, docId, apiNumber, parentContainer);
                    }
                } else if (result.error === 'no_credits') {
                    parentContainer.innerHTML = `
                        <button class="completion-analyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)">
                            Analyze
                        </button>`;
                    showMapToast('No credits available', 'error');
                } else {
                    throw new Error(result.message || result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('[MapWellRecords] Analyze error:', error);
                parentContainer.innerHTML = `
                    <button class="completion-analyze-btn error"
                            onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)">
                        Retry
                    </button>`;
                showMapToast('Error analyzing completion report', 'error');
            }
        }

        // Poll for completion report processing status
        function startMapCompletionPolling(entryId, docId, apiNumber, parentContainer) {
            const startTime = Date.now();
            const maxDuration = 5 * 60 * 1000; // 5 minutes

            const poll = async () => {
                if (Date.now() - startTime > maxDuration) {
                    parentContainer.innerHTML = `
                        <button class="completion-analyze-btn error"
                                onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)">
                            Retry
                        </button>`;
                    return;
                }

                try {
                    const response = await fetch(`/api/documents/${docId}`, { credentials: 'include' });
                    const result = await response.json();
                    const doc = result.document || result;

                    console.log(`[MapWellRecords] Poll status for ${docId}: ${doc.status}`);

                    // Check for completion - handle both 'complete' and 'processed' statuses
                    if (doc.status === 'complete' || doc.status === 'processed') {
                        mapAnalyzedCompletionsCache[entryId] = { documentId: docId };
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this, true)"
                                    title="Re-process this document">Re-analyze</button>
                            <button class="occ-view-doc-btn" onclick="openMapDocumentDetail('${docId}')" title="View analyzed document">View Doc ↗</button>`;
                        showMapToast('Completion report analyzed!', 'success');
                        // Refresh the completion reports list to show updated PUN
                        loadMapCompletionReports(apiNumber);
                    } else if (doc.status === 'error' || doc.status === 'failed') {
                        parentContainer.innerHTML = `
                            <button class="completion-analyze-btn error"
                                    onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)"
                                    title="${escapeHtml(doc.extraction_error || 'Error occurred')}">
                                Retry
                            </button>`;
                        showMapToast('Analysis failed: ' + (doc.extraction_error || 'Unknown error'), 'error');
                    } else {
                        // Still processing, continue polling
                        parentContainer.innerHTML = `
                            <button class="completion-analyze-btn ${doc.status === 'processing' ? 'processing' : 'queued'}" disabled>
                                <span class="spinner-sm"></span>${doc.status === 'processing' ? 'Processing...' : 'Queued...'}
                            </button>`;
                        setTimeout(poll, 5000);
                    }
                } catch (error) {
                    console.error('[MapWellRecords] Poll error:', error);
                    setTimeout(poll, 5000);
                }
            };

            setTimeout(poll, 5000);
        }

        // Simple toast notification for map modal
        function showMapToast(message, type = 'info') {
            // Create toast element
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                padding: 12px 24px;
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 500;
                z-index: 1000002;
                animation: fadeIn 0.3s ease;
                ${type === 'success' ? 'background: #10b981;' : type === 'error' ? 'background: #ef4444;' : 'background: #3b82f6;'}
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Load OTC production summary for a well
        async function loadMapOTCProduction(apiNumber) {
            console.log('[MapOTCProduction] Loading for API:', apiNumber);
            const section = document.getElementById('wellModalOTCProduction');
            const content = document.getElementById('wellModalOTCContent');
            const statusBadge = document.getElementById('wellModalOTCStatus');

            // Show loading state
            section.style.display = 'block';
            statusBadge.textContent = '...';
            content.innerHTML = '<div style="text-align: center; padding: 12px; color: var(--slate-blue);">Loading production data...</div>';

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000);

                const response = await fetch(`/api/wells/${apiNumber}/production-summary`, {
                    credentials: 'include',
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    if (response.status === 404) {
                        section.style.display = 'none';
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('[MapOTCProduction] Data received:', data);

                if (!data.production) {
                    section.style.display = 'none';
                    return;
                }

                renderMapOTCProduction(data);
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('[MapOTCProduction] Request timed out');
                } else {
                    console.error('[MapOTCProduction] Error:', error);
                }
                section.style.display = 'none';
            }
        }

        // Render OTC production data
        function renderMapOTCProduction(data) {
            const section = document.getElementById('wellModalOTCProduction');
            const content = document.getElementById('wellModalOTCContent');
            const statusBadge = document.getElementById('wellModalOTCStatus');

            // Store PUN for unit report
            section.dataset.pun = data.pun || '';

            const prod = data.production;
            const formatNum = (num) => num != null ? Number(num).toLocaleString() : '—';

            // Status info with colors and suffixes
            const statusMap = {
                'active': { text: 'Active', suffix: '(Last Reported: Within 3 Months)', color: '#22c55e' },
                'recently_idle': { text: 'Recently Idle', suffix: '', color: '#f59e0b' },
                'extended_idle': { text: 'Extended Idle', suffix: '', color: '#f97316' },
                'no_recent_production': { text: '⚠️ No Recent Reported Production', suffix: '', color: '#ef4444' }
            };
            const statusInfo = statusMap[data.status] || { text: data.status || 'Unknown', suffix: '', color: '#9ca3af' };
            statusBadge.textContent = statusInfo.text;

            // Last production date and months produced
            const lastProd = prod.lastProduction?.formatted || 'N/A';
            const monthsProduced = prod.monthsProduced || 0;

            // Build sparkline if data available
            let sparklineHtml = '';
            if (data.sparkline && data.sparkline.length > 0) {
                const points = data.sparkline;
                const months = data.sparklineMonths || [];
                const maxVal = Math.max(...points, 1);
                const height = 28;
                const width = 100;
                const step = points.length === 1 ? 0 : width / (points.length - 1);
                const coordPairs = points.map((val, i) => {
                    const x = points.length === 1 ? width / 2 : i * step;
                    const y = height - (val / maxVal) * (height - 4);
                    return { x, y, val, month: months[i] || '' };
                });
                const lineCoords = coordPairs.map(p => `${p.x},${p.y}`).join(' ');
                const circles = coordPairs.map(p =>
                    `<circle cx="${p.x}" cy="${p.y}" r="2.5" fill="${p.val > 0 ? '#3b82f6' : '#cbd5e1'}">
                        <title>${p.month}: ${p.val > 0 ? p.val.toLocaleString() + ' BOE' : 'No report'}</title>
                    </circle>`
                ).join('');
                sparklineHtml = `
                    <svg width="${width}" height="${height}" style="display: block;">
                        ${points.length > 1 ? `<polyline fill="none" stroke="#3b82f6" stroke-width="1.5" points="${lineCoords}"/>` : ''}
                        ${circles}
                    </svg>
                `;
            }

            content.innerHTML = `
                <!-- Header: Last Reported, Months Produced, PUN -->
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px; flex-wrap: wrap; gap: 8px;">
                    <div style="display: flex; gap: 16px;">
                        <div>
                            <div style="font-size: 10px; color: #6b7280; text-transform: uppercase;">Last Reported</div>
                            <div style="font-size: 13px; font-weight: 600; color: var(--oil-navy);">${lastProd}</div>
                        </div>
                        <div>
                            <div style="font-size: 10px; color: #6b7280; text-transform: uppercase;">Months Produced</div>
                            <div style="font-size: 13px; font-weight: 600; color: var(--oil-navy);">${monthsProduced.toLocaleString()}</div>
                        </div>
                    </div>
                    ${data.pun ? `<span style="background: rgba(22,101,52,0.1); color: #166534; padding: 3px 8px; border-radius: 4px; font-size: 11px; font-weight: 500;">✓ PUN: ${data.pun}</span>` : ''}
                </div>

                <!-- Data Grid -->
                <div style="display: grid; grid-template-columns: 80px 1fr 1fr 1fr; gap: 8px; font-size: 12px;">
                    <div></div>
                    <div style="color: #1e40af; text-align: center; font-size: 9px; font-weight: 600; text-transform: uppercase; background: rgba(59,130,246,0.1); padding: 4px 6px; border-radius: 4px;">${prod.lastMonth?.formatted || 'Last Rpt'}</div>
                    <div style="color: #1e40af; text-align: center; font-size: 9px; font-weight: 600; text-transform: uppercase; background: rgba(59,130,246,0.1); padding: 4px 6px; border-radius: 4px;">Last 12 Mo</div>
                    <div style="color: #1e40af; text-align: center; font-size: 9px; font-weight: 600; text-transform: uppercase; background: rgba(59,130,246,0.1); padding: 4px 6px; border-radius: 4px;">Lifetime</div>

                    <div style="font-weight: 600; color: #166534;">OIL</div>
                    <div style="text-align: right; font-weight: 600;">${formatNum(prod.lastMonth?.oil)} <span style="color: var(--slate-blue); font-weight: 400;">BBL</span></div>
                    <div style="text-align: right; font-weight: 600;">${formatNum(prod.last12Mo?.oil)} <span style="color: var(--slate-blue); font-weight: 400;">BBL</span></div>
                    <div style="text-align: right; font-weight: 600;">${formatNum(prod.lifetime?.oil)} <span style="color: var(--slate-blue); font-weight: 400;">BBL</span></div>

                    <div style="font-weight: 600; color: #dc2626;">GAS</div>
                    <div style="text-align: right; font-weight: 600;">${formatNum(prod.lastMonth?.gas)} <span style="color: var(--slate-blue); font-weight: 400;">MCF</span></div>
                    <div style="text-align: right; font-weight: 600;">${formatNum(prod.last12Mo?.gas)} <span style="color: var(--slate-blue); font-weight: 400;">MCF</span></div>
                    <div style="text-align: right; font-weight: 600;">${formatNum(prod.lifetime?.gas)} <span style="color: var(--slate-blue); font-weight: 400;">MCF</span></div>
                </div>

                <!-- Status Row with Sparkline -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border);">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${statusInfo.color};"></span>
                        <span style="font-weight: 500; font-size: 13px;">${statusInfo.text} ${data.status === 'active' ? statusInfo.suffix : (lastProd !== 'N/A' ? `(Last Reported: ${lastProd})` : '')}</span>
                    </div>
                    ${sparklineHtml ? `<div style="flex-shrink: 0;">${sparklineHtml}</div>` : ''}
                </div>
            `;
        }

        // Load OCC filings for the map modal
        async function loadMapOccFilings(section, township, range, meridian = 'IM') {
            console.log(`[MapOccFilings] Loading filings for S${section}-T${township}-R${range} ${meridian}`);

            const directContainer = document.getElementById('map-occ-direct');
            const adjacentContainer = document.getElementById('map-occ-adjacent');
            const adjacentWrapper = document.getElementById('map-occ-adjacent-wrapper');
            const emptyMessage = document.getElementById('map-occ-empty');
            const countBadge = document.getElementById('map-occ-count');
            const adjacentCountBadge = document.getElementById('map-occ-adjacent-count');

            // Reset
            directContainer.innerHTML = '<div style="padding: 12px; color: #6b7280;">Loading filings...</div>';
            adjacentContainer.innerHTML = '';
            adjacentWrapper.style.display = 'none';
            emptyMessage.style.display = 'none';
            countBadge.textContent = '—';

            try {
                const response = await fetch(
                    `/api/docket-entries?section=${section}&township=${encodeURIComponent(township)}&range=${encodeURIComponent(range)}&meridian=${encodeURIComponent(meridian)}&includeAdjacent=true`,
                    { credentials: 'include' }
                );
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to load filings');
                }

                const directFilings = data.direct || [];
                const adjacentFilings = data.adjacent || [];

                // Update count badge
                const totalCount = directFilings.length + adjacentFilings.length;
                countBadge.textContent = String(totalCount);

                if (directFilings.length === 0 && adjacentFilings.length === 0) {
                    directContainer.innerHTML = '';
                    emptyMessage.style.display = 'block';
                    return;
                }

                // Render direct filings
                if (directFilings.length > 0) {
                    directContainer.innerHTML = directFilings.map(filing => renderMapOccFiling(filing, false)).join('');
                } else {
                    directContainer.innerHTML = '<div style="color: #888; font-size: 13px; font-style: italic; padding: 8px 0;">No direct filings for this section</div>';
                }

                // Render adjacent filings
                if (adjacentFilings.length > 0) {
                    adjacentWrapper.style.display = 'block';
                    adjacentCountBadge.textContent = String(adjacentFilings.length);
                    adjacentContainer.innerHTML = adjacentFilings.map(filing => renderMapOccFiling(filing, true)).join('');
                }

                // Check which filings have already been analyzed
                const allFilings = [...directFilings, ...adjacentFilings];
                const analyzableFilings = allFilings.filter(f =>
                    (f.status === 'HEARD' || f.status === 'RECOMMENDED') && f.caseNumber
                );

                if (analyzableFilings.length > 0) {
                    const caseNumbers = analyzableFilings.map(f => f.caseNumber).join(',');
                    try {
                        const analyzedResponse = await fetch(
                            `/api/documents/by-occ-cases?cases=${encodeURIComponent(caseNumbers)}`,
                            { credentials: 'include' }
                        );
                        if (analyzedResponse.ok) {
                            const analyzedData = await analyzedResponse.json();

                            for (const filing of analyzableFilings) {
                                const caseNum = filing.caseNumber;
                                const caseNumClean = caseNum?.replace(/^CD\s*/i, '');
                                const analyzed = analyzedData[caseNum] ||
                                               analyzedData[caseNumClean] ||
                                               analyzedData[`CD${caseNumClean}`];

                                if (analyzed) {
                                    const buttonId = `occ-btn-${(filing.orderNumber || filing.caseNumber).replace(/[^a-zA-Z0-9]/g, '-')}`;
                                    const button = document.getElementById(buttonId);
                                    if (button) {
                                        const stateKey = filing.orderNumber || filing.caseNumber;
                                        occProcessingStates[stateKey] = { status: 'complete', documentId: analyzed.documentId, buttonEl: button };
                                        updateMapOccButtonState(button, 'complete', analyzed.documentId, analyzed.displayName);
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        console.log('[MapOccFilings] Could not check analyzed status:', err);
                    }
                }

            } catch (error) {
                console.error('[MapOccFilings] Error loading filings:', error);
                directContainer.innerHTML = '<div style="color: #dc3545; font-size: 13px; padding: 8px 0;">Error loading filings</div>';
                countBadge.textContent = '0';
            }
        }

        // Render a single OCC filing item
        function renderMapOccFiling(filing, isAdjacent = false) {
            const statusClass = getOccStatusClass(filing.status);
            const dateDisplay = formatOccDate(filing.hearingDate || filing.docketDate);
            const isUpcoming = isOccHearingUpcoming(filing.hearingDate, filing.status);

            let adjacentNote = '';
            if (isAdjacent && filing.section) {
                adjacentNote = `<span class="occ-adjacent-note">S${filing.section}-T${filing.township}-R${filing.range}</span>`;
            }

            const hasFinalOrder = filing.status === 'HEARD' || filing.status === 'RECOMMENDED';
            const orderNumber = filing.orderNumber || '';
            const caseNumber = filing.caseNumber || '';
            const buttonId = `occ-btn-${(orderNumber || caseNumber).replace(/[^a-zA-Z0-9]/g, '-')}`;

            let processButton = '';
            if (hasFinalOrder && caseNumber) {
                processButton = `
                    <div class="occ-filing-actions">
                        <button
                            id="${buttonId}"
                            class="occ-process-btn"
                            onclick="processMapOccFiling('${escapeHtmlAttr(caseNumber)}', '${escapeHtmlAttr(orderNumber)}', this)"
                            title="Uses 1 document credit"
                        >Analyze</button>
                    </div>
                `;
            }

            return `
                <div class="occ-filing-item">
                    <div class="occ-filing-main">
                        <div class="occ-filing-type">
                            ${isUpcoming ? '<span class="occ-hearing-warning" title="Hearing within 30 days">⚠️</span>' : ''}
                            ${escapeHtml(filing.reliefTypeDisplay)}
                            ${adjacentNote}
                        </div>
                        <div class="occ-filing-applicant">${escapeHtml(filing.applicant) || 'Unknown Applicant'}</div>
                        <div class="occ-filing-details">
                            <span class="occ-filing-case">${escapeHtml(filing.caseNumber)}</span>
                            <span class="occ-filing-status ${statusClass}">${escapeHtml(filing.statusDisplay)}</span>
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                        <div class="occ-filing-date">
                            ${dateDisplay}
                        </div>
                        ${processButton}
                    </div>
                </div>
            `;
        }

        // OCC helpers (getOccStatusClass, formatOccDate, isOccHearingUpcoming,
        // formatCompletionDate, parseCompletionDate) are in shared-occ-helpers.txt

        // Process OCC filing (Analyze button click)
        async function processMapOccFiling(caseNumber, orderNumber, buttonEl) {
            const stateKey = orderNumber || caseNumber;
            console.log(`[MapOccProcess] Processing ${caseNumber} (order: ${orderNumber})`);

            occProcessingStates[stateKey] = { status: 'fetching', buttonEl };
            updateMapOccButtonState(buttonEl, 'fetching');

            try {
                const response = await fetch('/api/occ/fetch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ caseNumber, orderNumber })
                });

                const result = await response.json();

                if (result.alreadyProcessed) {
                    console.log(`[MapOccProcess] Already processed: ${result.documentId}`);
                    occProcessingStates[stateKey] = { status: 'complete', documentId: result.documentId, buttonEl };
                    updateMapOccButtonState(buttonEl, 'complete', result.documentId, result.displayName);
                } else if (result.success) {
                    const docId = result.document.id;
                    const docStatus = result.document.status || 'pending';
                    console.log(`[MapOccProcess] Successfully queued: ${docId}, status: ${docStatus}`);

                    if (docStatus === 'complete') {
                        occProcessingStates[stateKey] = { status: 'complete', documentId: docId, buttonEl };
                        updateMapOccButtonState(buttonEl, 'complete', docId);
                    } else {
                        occProcessingStates[stateKey] = {
                            status: docStatus === 'processing' ? 'processing' : 'queued',
                            documentId: docId,
                            buttonEl,
                            pollStartTime: Date.now()
                        };
                        updateMapOccButtonState(buttonEl, docStatus === 'processing' ? 'processing' : 'queued');
                        startMapOccDocumentPolling(stateKey, docId, buttonEl);
                    }
                } else if (result.error === 'no_credits') {
                    console.log(`[MapOccProcess] No credits available`);
                    occProcessingStates[stateKey] = { status: 'idle', buttonEl };
                    updateMapOccButtonState(buttonEl, 'idle');
                    showToast('No credits available. Please upgrade or purchase credits.', 'error');
                } else {
                    throw new Error(result.message || result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('[MapOccProcess] Error:', error);
                occProcessingStates[stateKey] = { status: 'error', buttonEl };
                updateMapOccButtonState(buttonEl, 'error');
                showToast('Failed to process filing: ' + error.message, 'error');
            }
        }

        // Poll for document status
        function startMapOccDocumentPolling(stateKey, documentId, buttonEl) {
            const state = occProcessingStates[stateKey];
            if (!state || state.pollInterval) return;

            console.log(`[MapOccPoll] Starting polling for ${documentId}`);

            state.pollInterval = setInterval(async () => {
                const currentState = occProcessingStates[stateKey];
                if (!currentState) {
                    clearInterval(state.pollInterval);
                    return;
                }

                if (Date.now() - currentState.pollStartTime > OCC_MAX_POLL_DURATION) {
                    console.log(`[MapOccPoll] Max duration exceeded for ${documentId}`);
                    clearInterval(currentState.pollInterval);
                    currentState.pollInterval = null;
                    return;
                }

                try {
                    const response = await fetch(`/api/documents/${documentId}`, { credentials: 'include' });
                    if (!response.ok) return;

                    const data = await response.json();
                    const doc = data.document;
                    if (!doc) return;

                    console.log(`[MapOccPoll] Document ${documentId} status: ${doc.status}`);

                    if (doc.status === 'complete') {
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'complete';
                        updateMapOccButtonState(buttonEl, 'complete', documentId, doc.display_name);
                        showToast('Document analysis complete!', 'success');
                    } else if (doc.status === 'processing' && currentState.status !== 'processing') {
                        currentState.status = 'processing';
                        updateMapOccButtonState(buttonEl, 'processing');
                    } else if (doc.status === 'error') {
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'error';
                        updateMapOccButtonState(buttonEl, 'error');
                        showToast('Document processing failed', 'error');
                    }
                } catch (err) {
                    console.error(`[MapOccPoll] Error polling ${documentId}:`, err);
                }
            }, OCC_POLL_INTERVAL);
        }

        // Update OCC button state
        function updateMapOccButtonState(buttonEl, state, documentId = null, displayName = null) {
            if (!buttonEl) return;

            buttonEl.classList.remove('processing', 'complete', 'error', 'queued', 'fetching');
            buttonEl.onclick = null;

            switch (state) {
                case 'fetching':
                    buttonEl.classList.add('fetching');
                    buttonEl.disabled = true;
                    buttonEl.innerHTML = '<span class="spinner-sm"></span> Fetching...';
                    buttonEl.title = 'Downloading from OCC';
                    break;
                case 'queued':
                    buttonEl.classList.add('queued');
                    buttonEl.disabled = true;
                    buttonEl.innerHTML = '<span class="spinner-sm"></span> Queued...';
                    buttonEl.title = 'Waiting for processing';
                    break;
                case 'processing':
                    buttonEl.classList.add('processing');
                    buttonEl.disabled = true;
                    buttonEl.innerHTML = '<span class="spinner-sm"></span> Processing...';
                    buttonEl.title = 'Extracting document data';
                    break;
                case 'complete':
                    buttonEl.classList.add('complete');
                    buttonEl.disabled = false;
                    buttonEl.innerHTML = 'Analyzed ✓';
                    buttonEl.title = 'Click to view document details';
                    if (documentId) {
                        buttonEl.dataset.documentId = documentId;
                        buttonEl.dataset.displayName = displayName || '';
                        buttonEl.onclick = function() {
                            // Open document detail modal
                            openMapDocumentDetail(documentId, displayName || 'OCC Document');
                        };
                    }
                    break;
                case 'error':
                    buttonEl.classList.add('error');
                    buttonEl.disabled = false;
                    buttonEl.innerHTML = 'Retry';
                    buttonEl.title = 'Click to retry';
                    break;
                default:
                    buttonEl.disabled = false;
                    buttonEl.innerHTML = 'Analyze';
                    buttonEl.title = 'Uses 1 document credit';
            }
        }

        // Track well from modal
        async function trackWellFromModal() {
            const apiNumber = document.getElementById('wellModalApiNumber').value;
            const wellName = document.getElementById('wellModalTitle').textContent;
            const trackBtn = document.getElementById('wellModalTrackBtn');

            if (!apiNumber || apiNumber === 'Unknown') {
                showToast('Cannot track well: missing API number', 'error');
                return;
            }

            trackBtn.disabled = true;
            trackBtn.textContent = 'Adding...';

            try {
                await trackWell(apiNumber, wellName);
                trackBtn.textContent = '✓ Tracked';
                trackBtn.style.background = '#10b981';
                document.getElementById('wellModalIsTracked').value = '1';
                showToast('Well added to your tracked wells!', 'success');
            } catch (error) {
                console.error('Error tracking well:', error);
                trackBtn.disabled = false;
                trackBtn.textContent = '+ Track Well';
                showToast('Failed to track well: ' + error.message, 'error');
            }
        }

