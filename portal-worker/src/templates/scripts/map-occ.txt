        // ============================================
        // OCC Filings Functions for Map Modal
        // (processOccFiling, renderOccFiling, checkAnalyzedFilings,
        //  updateOccButtonState, startOccDocumentPolling, stopAllOccPolling
        //  are provided by shared-occ-filings.txt)
        // ============================================

        // Toggle OCC filings accordion
        function toggleMapOccFilings() {
            const content = document.getElementById('map-occ-content');
            const arrow = document.getElementById('map-occ-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // getMatchReasonStyle() and getMatchReasonLabel() are now defined in shared utilities at top of script

        async function mapUnlinkProperty(linkId, wellId) {
            if (!confirm('Remove this property link?')) return;
            try {
                const res = await fetch(`/api/property-well-link/${linkId}`, { method: 'DELETE', credentials: 'include' });
                if (res.ok) expandWellCard(wellId, true);
                else showMapToast('Failed to unlink', 'error');
            } catch (e) { showMapToast('Error: ' + e.message, 'error'); }
        }
        async function mapRelinkProperty(linkId, wellId) {
            try {
                const res = await fetch(`/api/property-well-link/${linkId}`, { method: 'PATCH', credentials: 'include' });
                if (res.ok) expandWellCard(wellId, true);
                else showMapToast('Failed to relink', 'error');
            } catch (e) { showMapToast('Error: ' + e.message, 'error'); }
        }

        // Toggle linked properties accordion
        function toggleMapLinkedProperties() {
            const content = document.getElementById('map-linked-props-content');
            const arrow = document.getElementById('map-linked-props-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // Toggle linked documents accordion
        function toggleMapLinkedDocs() {
            const content = document.getElementById('map-linked-docs-content');
            const arrow = document.getElementById('map-linked-docs-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // Toggle Well Records accordion
        function toggleMapWellRecords() {
            const content = document.getElementById('map-well-records-content');
            const arrow = document.getElementById('map-well-records-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // Toggle Drilling Permits accordion
        function toggleMapDrillingPermits() {
            const content = document.getElementById('map-drilling-permits-content');
            const arrow = document.getElementById('map-drilling-permits-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // ============================================
        // Well Records Functions (Completion Reports)
        // ============================================

        // State tracking for completion report processing
        const mapCompletionProcessingStates = {};
        const mapAnalyzedCompletionsCache = {};

        // Load completion reports for a well
        async function loadMapCompletionReports(apiNumber) {
            console.log('[MapWellRecords] Loading completion reports for API:', apiNumber);
            const countBadge = document.getElementById('wellModalWellRecordsCount');
            const reportsContainer = document.getElementById('wellModalCompletionReports');

            try {
                const response = await fetch(`/api/wells/${apiNumber}/completion-reports`, { credentials: 'include' });
                const data = await response.json();
                const completionReports = data.completionReports || [];

                console.log('[MapWellRecords] Found', completionReports.length, 'completion reports');

                // Update count badge (remove loading class, show count)
                countBadge.className = '';
                countBadge.style.cssText = 'background: #e5e7eb; padding: 2px 8px; border-radius: 12px; font-size: 12px;';
                countBadge.textContent = completionReports.length;

                if (completionReports.length === 0) {
                    reportsContainer.innerHTML = '<div style="color: #6b7280; font-size: 13px; font-style: italic; padding: 8px 0;">No completion reports found</div>';
                    return;
                }

                // Sort by effective date (newest first) - same as dashboard
                completionReports.sort((a, b) => {
                    const dateA = parseCompletionDate(a.effectiveDate);
                    const dateB = parseCompletionDate(b.effectiveDate);
                    return dateB - dateA;
                });

                // Render completion reports
                const html = completionReports.map((report, idx) => {
                    const isCurrent = idx === 0; // Most recent is "current"
                    return renderMapCompletionReport(report, apiNumber, isCurrent);
                }).join('');

                reportsContainer.innerHTML = html;

            } catch (error) {
                console.error('[MapWellRecords] Error loading completion reports:', error);
                countBadge.className = '';
                countBadge.style.cssText = 'background: #fecaca; padding: 2px 8px; border-radius: 12px; font-size: 12px; color: #dc2626;';
                countBadge.textContent = '!';
                reportsContainer.innerHTML = '<div style="color: #ef4444; font-size: 13px; padding: 8px 0;">Error loading completion reports</div>';
            }
        }

        // Render a completion report item
        function renderMapCompletionReport(report, apiNumber, isCurrent) {
            const isRecompletion = report.formType === '1002C';
            const typeClass = isRecompletion ? 'recompletion' : 'completion';
            const typeLabel = isRecompletion ? 'RECOMPLETION 1002C' : 'COMPLETION 1002A';
            const dateDisplay = formatCompletionDate(report.effectiveDate);
            const buttonId = `map-completion-btn-${report.entryId}`;
            const currentBadge = isCurrent ? '<span class="completion-current-badge">Current</span>' : '';

            // Check client-side cache first
            const cached = mapAnalyzedCompletionsCache[report.entryId];

            // Resolve which function opens document detail on this page
            const openDocFn = typeof openDocumentDetail === 'function' ? 'openDocumentDetail'
                            : typeof openMapDocumentDetail === 'function' ? 'openMapDocumentDetail'
                            : 'openDocumentDetail';

            // Render action button based on status
            let actionButton = '';
            if (cached && cached.documentId) {
                actionButton = `
                    <button class="occ-reanalyze-btn"
                            onclick="analyzeMapCompletion('${apiNumber}', ${report.entryId}, this, true)"
                            title="Re-process this document">Re-analyze</button>
                    <button class="occ-view-doc-btn" onclick="${openDocFn}('${cached.documentId}')" title="View analyzed document">View Doc ↗</button>`;
            } else switch (report.status) {
                case 'available':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${report.entryId}, this)">
                            Analyze
                        </button>`;
                    break;
                case 'fetching':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn fetching" disabled>
                            <span class="spinner-sm"></span>Analyzing...
                        </button>`;
                    break;
                case 'fetched':
                case 'processed':
                    actionButton = `
                        <button class="occ-reanalyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${report.entryId}, this, true)"
                                title="Re-process this document">Re-analyze</button>
                        ${report.documentId ? `<button class="occ-view-doc-btn" onclick="${openDocFn}('${report.documentId}')" title="View analyzed document">View Doc ↗</button>` : ''}`;
                    break;
                case 'error':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn error"
                                onclick="analyzeMapCompletion('${apiNumber}', ${report.entryId}, this)"
                                title="${escapeHtml(report.errorMessage || 'Error occurred')}">
                            Retry
                        </button>`;
                    break;
                default:
                    actionButton = '<span style="color: #888; font-size: 12px;">—</span>';
            }

            return `
                <div class="completion-report-item${isCurrent ? ' is-current' : ''}">
                    <div class="completion-report-main">
                        <div>
                            <span class="completion-report-type ${typeClass}">${typeLabel}</span>
                            ${currentBadge}
                            <span class="completion-report-location">${escapeHtml(report.location || '')}</span>
                        </div>
                        <div class="completion-report-details">
                            ${report.county ? `<span>${escapeHtml(report.county)} County</span>` : ''}
                            ${report.wellName ? `<span>• ${escapeHtml(report.wellName)}</span>` : ''}
                            ${report.pun ? `<span class="completion-report-pun">PUN: ${escapeHtml(report.pun)}</span>` : ''}
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div class="occ-filing-actions">
                            ${actionButton}
                        </div>
                        <div class="completion-report-date">${dateDisplay}</div>
                    </div>
                </div>
            `;
        }

        // Analyze completion report
        async function analyzeMapCompletion(apiNumber, entryId, buttonEl, force = false) {
            console.log(`[MapWellRecords] ${force ? 'Re-analyzing' : 'Analyzing'} ${apiNumber} entryId ${entryId}`);

            const parentContainer = buttonEl.closest('.occ-filing-actions');
            if (!parentContainer) return;

            // Resolve which function opens document detail on this page
            const openDocFn = typeof openDocumentDetail === 'function' ? 'openDocumentDetail'
                            : typeof openMapDocumentDetail === 'function' ? 'openMapDocumentDetail'
                            : 'openDocumentDetail';

            // Update to fetching state
            mapCompletionProcessingStates[entryId] = { status: 'fetching', buttonEl };
            parentContainer.innerHTML = `
                <button class="completion-analyze-btn fetching" disabled>
                    <span class="spinner-sm"></span>${force ? 'Re-analyzing...' : 'Fetching...'}
                </button>`;

            try {
                const response = await fetch('/api/occ/fetch-1002a', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ apiNumber, entryId, force })
                });

                const result = await response.json();

                if (response.status === 401) {
                    parentContainer.innerHTML = `
                        <button class="completion-analyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)">
                            Analyze
                        </button>`;
                    showMapToast('Please log in to analyze completion reports', 'error');
                    return;
                }

                if (result.alreadyProcessed) {
                    console.log(`[MapWellRecords] Already processed: ${result.documentId}`);
                    mapAnalyzedCompletionsCache[entryId] = { documentId: result.documentId };
                    parentContainer.innerHTML = `
                        <button class="occ-reanalyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this, true)"
                                title="Re-process this document">Re-analyze</button>
                        <button class="occ-view-doc-btn" onclick="${openDocFn}('${result.documentId}')" title="View analyzed document">View Doc ↗</button>`;
                } else if (result.success) {
                    const docId = result.document.id;
                    const docStatus = result.document.status || 'pending';
                    console.log(`[MapWellRecords] Successfully queued: ${docId}, status: ${docStatus}`);

                    // Check for completion - handle both 'complete' and 'processed' statuses
                    if (docStatus === 'complete' || docStatus === 'processed') {
                        mapAnalyzedCompletionsCache[entryId] = { documentId: docId };
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this, true)"
                                    title="Re-process this document">Re-analyze</button>
                            <button class="occ-view-doc-btn" onclick="${openDocFn}('${docId}')" title="View analyzed document">View Doc ↗</button>`;
                        showMapToast('Completion report analyzed!', 'success');
                        // Refresh the completion reports list to show updated PUN
                        loadMapCompletionReports(apiNumber);
                    } else {
                        // Start polling
                        parentContainer.innerHTML = `
                            <button class="completion-analyze-btn ${docStatus === 'processing' ? 'processing' : 'queued'}" disabled>
                                <span class="spinner-sm"></span>${docStatus === 'processing' ? 'Processing...' : 'Queued...'}
                            </button>`;
                        startMapCompletionPolling(entryId, docId, apiNumber, parentContainer);
                    }
                } else if (result.error === 'no_credits') {
                    parentContainer.innerHTML = `
                        <button class="completion-analyze-btn"
                                onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)">
                            Analyze
                        </button>`;
                    showMapToast('No credits available', 'error');
                } else {
                    throw new Error(result.message || result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('[MapWellRecords] Analyze error:', error);
                parentContainer.innerHTML = `
                    <button class="completion-analyze-btn error"
                            onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)">
                        Retry
                    </button>`;
                showMapToast('Error analyzing completion report', 'error');
            }
        }

        // Poll for completion report processing status
        function startMapCompletionPolling(entryId, docId, apiNumber, parentContainer) {
            const startTime = Date.now();
            const maxDuration = 5 * 60 * 1000; // 5 minutes

            // Resolve which function opens document detail on this page
            const openDocFn = typeof openDocumentDetail === 'function' ? 'openDocumentDetail'
                            : typeof openMapDocumentDetail === 'function' ? 'openMapDocumentDetail'
                            : 'openDocumentDetail';

            const poll = async () => {
                if (Date.now() - startTime > maxDuration) {
                    parentContainer.innerHTML = `
                        <button class="completion-analyze-btn error"
                                onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)">
                            Retry
                        </button>`;
                    return;
                }

                try {
                    const response = await fetch(`/api/documents/${docId}`, { credentials: 'include' });
                    const result = await response.json();
                    const doc = result.document || result;

                    console.log(`[MapWellRecords] Poll status for ${docId}: ${doc.status}`);

                    // Check for completion - handle both 'complete' and 'processed' statuses
                    if (doc.status === 'complete' || doc.status === 'processed') {
                        mapAnalyzedCompletionsCache[entryId] = { documentId: docId };
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this, true)"
                                    title="Re-process this document">Re-analyze</button>
                            <button class="occ-view-doc-btn" onclick="${openDocFn}('${docId}')" title="View analyzed document">View Doc ↗</button>`;
                        showMapToast('Completion report analyzed!', 'success');
                        // Refresh the completion reports list to show updated PUN
                        loadMapCompletionReports(apiNumber);
                    } else if (doc.status === 'error' || doc.status === 'failed') {
                        parentContainer.innerHTML = `
                            <button class="completion-analyze-btn error"
                                    onclick="analyzeMapCompletion('${apiNumber}', ${entryId}, this)"
                                    title="${escapeHtml(doc.extraction_error || 'Error occurred')}">
                                Retry
                            </button>`;
                        showMapToast('Analysis failed: ' + (doc.extraction_error || 'Unknown error'), 'error');
                    } else {
                        // Still processing, continue polling
                        parentContainer.innerHTML = `
                            <button class="completion-analyze-btn ${doc.status === 'processing' ? 'processing' : 'queued'}" disabled>
                                <span class="spinner-sm"></span>${doc.status === 'processing' ? 'Processing...' : 'Queued...'}
                            </button>`;
                        setTimeout(poll, 5000);
                    }
                } catch (error) {
                    console.error('[MapWellRecords] Poll error:', error);
                    setTimeout(poll, 5000);
                }
            };

            setTimeout(poll, 5000);
        }

        // Simple toast notification for map modal
        function showMapToast(message, type = 'info') {
            // Create toast element
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                padding: 12px 24px;
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 500;
                z-index: 1000002;
                animation: fadeIn 0.3s ease;
                ${type === 'success' ? 'background: #10b981;' : type === 'error' ? 'background: #ef4444;' : 'background: #3b82f6;'}
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ============================================
        // Drilling Permits Functions
        // ============================================

        const mapAnalyzedPermitsCache = {};

        async function loadMapDrillingPermits(apiNumber) {
            console.log('[MapDrillingPermits] Loading permits for API:', apiNumber);
            const countBadge = document.getElementById('wellModalDrillingPermitsCount');
            const container = document.getElementById('wellModalDrillingPermits');

            try {
                const response = await fetch(`/api/wells/${apiNumber}/drilling-permits`, { credentials: 'include' });
                const data = await response.json();
                const permits = data.drillingPermits || [];

                console.log('[MapDrillingPermits] Found', permits.length, 'permits');

                countBadge.className = '';
                countBadge.style.cssText = 'background: #e5e7eb; padding: 2px 8px; border-radius: 12px; font-size: 12px;';
                countBadge.textContent = permits.length;

                if (permits.length === 0) {
                    container.innerHTML = '<div style="color: #6b7280; font-size: 13px; font-style: italic; padding: 8px 0;">No drilling permits found</div>';
                    return;
                }

                // Sort by effective date (newest first)
                permits.sort((a, b) => {
                    const dateA = parseCompletionDate(a.effectiveDate);
                    const dateB = parseCompletionDate(b.effectiveDate);
                    return dateB - dateA;
                });

                // Populate cache for already-analyzed permits
                for (const permit of permits) {
                    if (permit.documentId && (permit.status === 'fetched' || permit.status === 'processed')) {
                        mapAnalyzedPermitsCache[permit.entryId] = { documentId: permit.documentId, displayName: permit.wellName };
                    }
                }

                container.innerHTML = permits.map((permit, idx) => renderMapDrillingPermit(permit, apiNumber, idx === 0)).join('');
            } catch (error) {
                console.error('[MapDrillingPermits] Error loading permits:', error);
                countBadge.className = '';
                countBadge.style.cssText = 'background: #fecaca; padding: 2px 8px; border-radius: 12px; font-size: 12px; color: #dc2626;';
                countBadge.textContent = '!';
                container.innerHTML = '<div style="color: #ef4444; font-size: 13px; padding: 8px 0;">Error loading drilling permits</div>';
            }
        }

        function renderMapDrillingPermit(permit, apiNumber, isCurrent = false) {
            const dateDisplay = formatCompletionDate(permit.effectiveDate);
            const buttonId = `map-permit-btn-${permit.entryId}`;
            const isFailed = permit.status === 'error';
            const currentBadge = isCurrent ? '<span class="completion-current-badge">Latest</span>' : '';
            const failedBadge = isFailed ? `<span class="completion-failed-badge" title="${escapeHtml(permit.errorMessage || 'Processing failed')}">Failed</span>` : '';

            const cached = mapAnalyzedPermitsCache[permit.entryId];

            const openDocFn = typeof openDocumentDetail === 'function' ? 'openDocumentDetail'
                            : typeof openMapDocumentDetail === 'function' ? 'openMapDocumentDetail'
                            : 'openDocumentDetail';

            let actionButton = '';
            if (cached && cached.documentId) {
                actionButton = `
                    <button class="occ-reanalyze-btn"
                            onclick="analyzeMapPermit('${apiNumber}', ${permit.entryId}, this, true)"
                            title="Re-process this document">Re-analyze</button>
                    <button class="occ-view-doc-btn" onclick="${openDocFn}('${cached.documentId}')" title="View analyzed document">View Doc ↗</button>`;
            } else switch (permit.status) {
                case 'available':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn"
                                onclick="analyzeMapPermit('${apiNumber}', ${permit.entryId}, this)">
                            Analyze
                        </button>`;
                    break;
                case 'fetching':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn fetching" disabled>
                            <span class="spinner-sm"></span>Analyzing...
                        </button>`;
                    break;
                case 'fetched':
                case 'processed':
                    actionButton = `
                        <button class="occ-reanalyze-btn"
                                onclick="analyzeMapPermit('${apiNumber}', ${permit.entryId}, this, true)"
                                title="Re-process this document">Re-analyze</button>
                        ${permit.documentId ? `<button class="occ-view-doc-btn" onclick="${openDocFn}('${permit.documentId}')" title="View analyzed document">View Doc ↗</button>` : ''}`;
                    break;
                case 'error':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn error"
                                onclick="analyzeMapPermit('${apiNumber}', ${permit.entryId}, this, true)"
                                title="${escapeHtml(permit.errorMessage || 'Error occurred')}">
                            Retry
                        </button>`;
                    break;
                default:
                    actionButton = '<span style="color: #888; font-size: 12px;">—</span>';
            }

            return `
                <div class="completion-report-item${isCurrent ? ' is-current' : ''}${isFailed ? ' is-failed' : ''}">
                    <div class="completion-report-main">
                        <div>
                            <span class="completion-report-type" style="background: #DBEAFE; color: #1E40AF;">PERMIT 1000</span>
                            ${currentBadge}
                            ${failedBadge}
                            <span class="completion-report-location">${escapeHtml(permit.location || '')}</span>
                        </div>
                        <div class="completion-report-details">
                            ${permit.county ? `<span>${escapeHtml(permit.county)} County</span>` : ''}
                            ${permit.wellName ? `<span>• ${escapeHtml(permit.wellName)}</span>` : ''}
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                        <div class="completion-report-date">${dateDisplay}</div>
                        <div class="occ-filing-actions">
                            ${actionButton}
                        </div>
                    </div>
                </div>
            `;
        }

        // Analyze drilling permit from map modal
        async function analyzeMapPermit(apiNumber, entryId, buttonEl, force = false) {
            console.log(`[MapDrillingPermits] ${force ? 'Re-analyzing' : 'Analyzing'} ${apiNumber} entryId ${entryId}`);

            const parentContainer = buttonEl.closest('.occ-filing-actions');
            if (!parentContainer) return;

            const openDocFn = typeof openDocumentDetail === 'function' ? 'openDocumentDetail'
                            : typeof openMapDocumentDetail === 'function' ? 'openMapDocumentDetail'
                            : 'openDocumentDetail';

            parentContainer.innerHTML = `
                <button class="completion-analyze-btn fetching" disabled>
                    <span class="spinner-sm"></span>${force ? 'Re-analyzing...' : 'Fetching...'}
                </button>`;

            try {
                const response = await fetch(`/api/wells/${apiNumber}/analyze-permit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ entryId, force })
                });

                const result = await response.json();

                if (response.status === 401) {
                    parentContainer.innerHTML = `
                        <button class="completion-analyze-btn"
                                onclick="analyzeMapPermit('${apiNumber}', ${entryId}, this)">
                            Analyze
                        </button>`;
                    showMapToast('Please log in to analyze drilling permits', 'error');
                    return;
                }

                if (result.alreadyProcessed) {
                    mapAnalyzedPermitsCache[entryId] = { documentId: result.documentId };
                    parentContainer.innerHTML = `
                        <button class="occ-reanalyze-btn"
                                onclick="analyzeMapPermit('${apiNumber}', ${entryId}, this, true)"
                                title="Re-process this document">Re-analyze</button>
                        <button class="occ-view-doc-btn" onclick="${openDocFn}('${result.documentId}')" title="View analyzed document">View Doc ↗</button>`;
                } else if (result.success) {
                    const docId = result.document.id;
                    const docStatus = result.document.status || 'pending';

                    if (docStatus === 'complete' || docStatus === 'processed') {
                        mapAnalyzedPermitsCache[entryId] = { documentId: docId };
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    onclick="analyzeMapPermit('${apiNumber}', ${entryId}, this, true)"
                                    title="Re-process this document">Re-analyze</button>
                            <button class="occ-view-doc-btn" onclick="${openDocFn}('${docId}')" title="View analyzed document">View Doc ↗</button>`;
                        showMapToast('Drilling permit analyzed!', 'success');
                        loadMapDrillingPermits(apiNumber);
                    } else {
                        parentContainer.innerHTML = `
                            <button class="completion-analyze-btn ${docStatus === 'processing' ? 'processing' : 'queued'}" disabled>
                                <span class="spinner-sm"></span>${docStatus === 'processing' ? 'Processing...' : 'Queued...'}
                            </button>`;
                        startMapPermitPolling(entryId, docId, apiNumber, parentContainer);
                    }
                } else if (result.error === 'no_credits') {
                    parentContainer.innerHTML = `
                        <button class="completion-analyze-btn"
                                onclick="analyzeMapPermit('${apiNumber}', ${entryId}, this)">
                            Analyze
                        </button>`;
                    showMapToast('No credits available', 'error');
                } else {
                    throw new Error(result.message || result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('[MapDrillingPermits] Analyze error:', error);
                parentContainer.innerHTML = `
                    <button class="completion-analyze-btn error"
                            onclick="analyzeMapPermit('${apiNumber}', ${entryId}, this)">
                        Retry
                    </button>`;
                showMapToast('Error analyzing drilling permit', 'error');
            }
        }

        // Poll for drilling permit processing status
        function startMapPermitPolling(entryId, docId, apiNumber, parentContainer) {
            const startTime = Date.now();
            const maxDuration = 5 * 60 * 1000;

            const openDocFn = typeof openDocumentDetail === 'function' ? 'openDocumentDetail'
                            : typeof openMapDocumentDetail === 'function' ? 'openMapDocumentDetail'
                            : 'openDocumentDetail';

            const poll = async () => {
                if (Date.now() - startTime > maxDuration) {
                    parentContainer.innerHTML = `
                        <button class="completion-analyze-btn error"
                                onclick="analyzeMapPermit('${apiNumber}', ${entryId}, this)">
                            Retry
                        </button>`;
                    return;
                }

                try {
                    const response = await fetch(`/api/documents/${docId}`, { credentials: 'include' });
                    const result = await response.json();
                    const doc = result.document || result;

                    if (doc.status === 'complete' || doc.status === 'processed') {
                        mapAnalyzedPermitsCache[entryId] = { documentId: docId };
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    onclick="analyzeMapPermit('${apiNumber}', ${entryId}, this, true)"
                                    title="Re-process this document">Re-analyze</button>
                            <button class="occ-view-doc-btn" onclick="${openDocFn}('${docId}')" title="View analyzed document">View Doc ↗</button>`;
                        showMapToast('Drilling permit analyzed!', 'success');
                        loadMapDrillingPermits(apiNumber);
                    } else if (doc.status === 'error' || doc.status === 'failed') {
                        parentContainer.innerHTML = `
                            <button class="completion-analyze-btn error"
                                    onclick="analyzeMapPermit('${apiNumber}', ${entryId}, this)"
                                    title="${escapeHtml(doc.extraction_error || 'Error occurred')}">
                                Retry
                            </button>`;
                        showMapToast('Analysis failed: ' + (doc.extraction_error || 'Unknown error'), 'error');
                    } else {
                        parentContainer.innerHTML = `
                            <button class="completion-analyze-btn ${doc.status === 'processing' ? 'processing' : 'queued'}" disabled>
                                <span class="spinner-sm"></span>${doc.status === 'processing' ? 'Processing...' : 'Queued...'}
                            </button>`;
                        setTimeout(poll, 5000);
                    }
                } catch (error) {
                    console.error('[MapDrillingPermits] Poll error:', error);
                    setTimeout(poll, 5000);
                }
            };

            setTimeout(poll, 5000);
        }

        // Load OTC production summary for a well (uses shared renderer)
        async function loadMapOTCProduction(apiNumber) {
            console.log('[MapOTCProduction] Loading for API:', apiNumber);
            loadOTCProduction(apiNumber, {
                container: document.getElementById('wellModalOTCContent'),
                statusBadge: document.getElementById('wellModalOTCStatus'),
                section: document.getElementById('wellModalOTCProduction')
            });
        }

        // Load OCC filings for the map modal
        async function loadMapOccFilings(section, township, range, meridian = 'IM') {
            console.log(`[MapOccFilings] Loading filings for S${section}-T${township}-R${range} ${meridian}`);

            const directContainer = document.getElementById('map-occ-direct');
            const adjacentContainer = document.getElementById('map-occ-adjacent');
            const adjacentWrapper = document.getElementById('map-occ-adjacent-wrapper');
            const emptyMessage = document.getElementById('map-occ-empty');
            const countBadge = document.getElementById('map-occ-count');
            const adjacentCountBadge = document.getElementById('map-occ-adjacent-count');

            // Reset
            directContainer.innerHTML = '<div style="padding: 12px; color: #6b7280;">Loading filings...</div>';
            adjacentContainer.innerHTML = '';
            adjacentWrapper.style.display = 'none';
            emptyMessage.style.display = 'none';
            countBadge.textContent = '—';

            try {
                const response = await fetch(
                    `/api/docket-entries?section=${section}&township=${encodeURIComponent(township)}&range=${encodeURIComponent(range)}&meridian=${encodeURIComponent(meridian)}&includeAdjacent=true`,
                    { credentials: 'include' }
                );
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to load filings');
                }

                const directFilings = data.direct || [];
                const adjacentFilings = data.adjacent || [];

                // Update count badge
                const totalCount = directFilings.length + adjacentFilings.length;
                countBadge.textContent = String(totalCount);

                if (directFilings.length === 0 && adjacentFilings.length === 0) {
                    directContainer.innerHTML = '';
                    emptyMessage.style.display = 'block';
                    return;
                }

                // Render direct filings
                if (directFilings.length > 0) {
                    directContainer.innerHTML = directFilings.map(filing => renderOccFiling(filing, false)).join('');
                } else {
                    directContainer.innerHTML = '<div style="color: #888; font-size: 13px; font-style: italic; padding: 8px 0;">No direct filings for this section</div>';
                }

                // Render adjacent filings
                if (adjacentFilings.length > 0) {
                    adjacentWrapper.style.display = 'block';
                    adjacentCountBadge.textContent = String(adjacentFilings.length);
                    adjacentContainer.innerHTML = adjacentFilings.map(filing => renderOccFiling(filing, true)).join('');
                }

                // Check which filings have already been analyzed
                const allFilings = [...directFilings, ...adjacentFilings];
                const analyzableFilings = allFilings.filter(f =>
                    (f.status === 'HEARD' || f.status === 'RECOMMENDED') && f.caseNumber
                );

                if (analyzableFilings.length > 0) {
                    checkAnalyzedFilings(analyzableFilings);
                }

            } catch (error) {
                console.error('[MapOccFilings] Error loading filings:', error);
                directContainer.innerHTML = '<div style="color: #dc3545; font-size: 13px; padding: 8px 0;">Error loading filings</div>';
                countBadge.textContent = '0';
            }
        }

        // OCC helpers (getOccStatusClass, formatOccDate, isOccHearingUpcoming,
        // formatCompletionDate, parseCompletionDate) are in shared-occ-helpers.txt
        // renderOccFiling, processOccFiling, updateOccButtonState,
        // startOccDocumentPolling, checkAnalyzedFilings, stopAllOccPolling
        // are in shared-occ-filings.txt

        // Track well from modal
        async function trackWellFromModal() {
            const apiNumber = document.getElementById('wellModalApiNumber').value;
            const wellName = document.getElementById('wellModalTitle').textContent;
            const trackBtn = document.getElementById('wellModalTrackBtn');

            if (!apiNumber || apiNumber === 'Unknown') {
                showToast('Cannot track well: missing API number', 'error');
                return;
            }

            trackBtn.disabled = true;
            trackBtn.textContent = 'Adding...';

            try {
                await trackWell(apiNumber, wellName);
                trackBtn.textContent = '✓ Tracked';
                trackBtn.style.background = '#10b981';
                document.getElementById('wellModalIsTracked').value = '1';
                showToast('Well added to your tracked wells!', 'success');
            } catch (error) {
                console.error('Error tracking well:', error);
                trackBtn.disabled = false;
                trackBtn.textContent = '+ Track Well';
                showToast('Failed to track well: ' + error.message, 'error');
            }
        }

