        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Auth: impersonation must run BEFORE any fetch calls
                const actAs = setupImpersonation();

                // Check for credit pack purchase success
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('purchase') === 'success') {
                    const newUrl = window.location.pathname;
                    window.history.replaceState({}, '', newUrl);
                    setTimeout(() => {
                        showToast('Credit pack purchased successfully! Credits have been added to your account.', 'success', 6000);
                    }, 500);
                }

                currentUser = await checkAuth();
                if (!currentUser) return;
                showSuperAdminNav();

                // Dashboard-specific: plan badge and limits
                const planBadge = document.getElementById('planBadge');
                planBadge.textContent = currentUser.plan || 'FREE';
                planBadge.style.visibility = 'visible';
                const limits = planConfigs[currentUser.plan] || { properties: 1, wells: 0 };
                document.getElementById('propLimit').textContent = limits.properties === Infinity ? '∞' : limits.properties;
                document.getElementById('wellLimit').textContent = limits.wells === Infinity ? '∞' : limits.wells;

                // Load impersonation banner (overrides currentUser.name/email/plan)
                if (actAs) {
                    await loadImpersonationBanner(actAs);
                    // Re-apply plan badge/limits with impersonated user's plan
                    document.getElementById('planBadge').textContent = currentUser.plan || 'FREE';
                    const targetLimits = planConfigs[currentUser.plan] || planConfigs['Free'] || { properties: 1, wells: 0 };
                    document.getElementById('propLimit').textContent = targetLimits.properties === Infinity ? '∞' : targetLimits.properties;
                    document.getElementById('wellLimit').textContent = targetLimits.wells === Infinity ? '∞' : targetLimits.wells;
                }

                // Hide upgrade link for Business/Enterprise users
                if (currentUser.plan === 'Business' || (currentUser.plan && currentUser.plan.startsWith('Enterprise'))) {
                    document.getElementById('upgradeLink').style.display = 'none';
                }

                // Show export buttons for Professional+ users
                if (currentUser.plan === 'Professional' || currentUser.plan === 'Business' || (currentUser.plan && currentUser.plan.startsWith('Enterprise'))) {
                    document.getElementById('exportPropertiesBtn').style.display = 'inline-flex';
                    document.getElementById('exportWellsBtn').style.display = 'inline-flex';
                }

                // Show Find Matches button for all users
                document.getElementById('findMatchesBtn').style.display = 'inline-flex';

                // Show Documents tab for all users
                console.log('Showing documents tab for all users');
                document.getElementById('documentsTab').style.display = 'flex';
                // Also show document count in plan info
                if (document.getElementById('docCountItem')) {
                    document.getElementById('docCountItem').style.display = 'flex';
                    document.getElementById('docCountDisplay').style.display = 'flex';
                }

                // Show mobile photo upload section only on mobile devices
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    // Show prominent photo upload section above search bar
                    const mobilePhotoSection = document.getElementById('mobilePhotoUploadSection');
                    if (mobilePhotoSection) {
                        mobilePhotoSection.style.display = 'block';
                    }
                }
                
                // Hide add/edit/delete buttons for Viewers
                if (currentUser.role === 'Viewer') {
                    // Hide property add/import buttons
                    const addPropertyBtn = document.getElementById('addPropertyBtn');
                    const bulkUploadBtn = document.getElementById('bulkUploadBtn');
                    if (addPropertyBtn) addPropertyBtn.style.display = 'none';
                    if (bulkUploadBtn) bulkUploadBtn.style.display = 'none';

                    // Hide well add/import buttons
                    const addWellBtn = document.getElementById('addWellBtn');
                    const bulkUploadWellsBtn = document.getElementById('bulkUploadWellsBtn');
                    if (addWellBtn) addWellBtn.style.display = 'none';
                    if (bulkUploadWellsBtn) bulkUploadWellsBtn.style.display = 'none';

                    // Hide bulk action bars (delete buttons)
                    const propertiesBulkActionBar = document.getElementById('propertiesBulkActionBar');
                    const wellsBulkActionBar = document.getElementById('wellsBulkActionBar');
                    const activityBulkActionBar = document.getElementById('activityBulkActionBar');
                    if (propertiesBulkActionBar) propertiesBulkActionBar.style.display = 'none';
                    if (wellsBulkActionBar) wellsBulkActionBar.style.display = 'none';
                    if (activityBulkActionBar) activityBulkActionBar.style.display = 'none';

                    // Hide the dividers between action groups when buttons are hidden
                    document.querySelectorAll('.action-divider').forEach(d => d.style.display = 'none');
                }
                
                await loadAllData();

                // Deferred localStorage cleanup for section geometry cache
                setTimeout(() => {
                    try {
                        const TTL = 7 * 24 * 60 * 60 * 1000;
                        const MAX = 500;
                        const now = Date.now();
                        const entries = [];
                        for (let i = localStorage.length - 1; i >= 0; i--) {
                            const key = localStorage.key(i);
                            if (key && key.startsWith('mw_section_')) {
                                let ts = 0;
                                try { const v = JSON.parse(localStorage.getItem(key)); ts = v && v.t ? v.t : 0; } catch(e) {}
                                entries.push({ key, ts });
                            }
                        }
                        // Evict expired
                        const alive = [];
                        for (const e of entries) {
                            if (e.ts > 0 && (now - e.ts) > TTL) {
                                localStorage.removeItem(e.key);
                            } else {
                                alive.push(e);
                            }
                        }
                        // Cap at 500 — remove oldest first
                        if (alive.length > MAX) {
                            alive.sort((a, b) => a.ts - b.ts);
                            const remove = alive.length - MAX;
                            for (let i = 0; i < remove; i++) {
                                localStorage.removeItem(alive[i].key);
                            }
                        }
                    } catch (e) {}
                }, 0);

                // Initialize search/sort controls
                initWellsControls();
                initPropertiesControls();
                initDocumentsControls();

                // Tab strip scroll fade hint — hide when scrolled to end
                const tabsEl = document.querySelector('.tabs');
                if (tabsEl) {
                    tabsEl.addEventListener('scroll', () => {
                        const atEnd = tabsEl.scrollLeft + tabsEl.clientWidth >= tabsEl.scrollWidth - 4;
                        tabsEl.classList.toggle('scrolled-end', atEnd);
                    });
                }
            } catch (err) {
                console.error('Dashboard init error:', err);
                if (!window.currentUser) {
                    // Auth actually failed — redirect to login
                    window.location.href = '/portal/login';
                } else {
                    // Auth succeeded but something else broke — show error, don't redirect
                    const msg = (err && err.message) ? err.message : String(err);
                    console.error('Post-auth init error (NOT redirecting):', msg);
                    const banner = document.createElement('div');
                    banner.style.cssText = 'position:fixed;top:0;left:0;right:0;z-index:99999;background:#e53e3e;color:#fff;padding:12px 16px;text-align:center;font-size:14px;';
                    banner.textContent = 'Dashboard init error: ' + msg;
                    document.body.prepend(banner);
                }
            }

            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', async () => {
                    currentTab = tab.dataset.tab;
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(currentTab + '-tab').classList.add('active');

                    if (currentTab === 'wells' && !wellsInitialized) {
                        wellsInitialized = true;
                        loadWells().catch(() => { wellsInitialized = false; });
                    }
                    if (currentTab === 'activity' && !activityInitialized) {
                        activityInitialized = true;
                        loadActivity().catch(() => { activityInitialized = false; });
                    }
                    if (currentTab === 'documents') {
                        if (!documentsInitialized) {
                            documentsInitialized = true;
                            Promise.all([loadDocuments(), loadUsageStats()])
                                .catch(() => { documentsInitialized = false; });
                        }
                    } else {
                        stopDocumentPolling();
                    }
                    if (currentTab === 'tools') {
                        if (!wellsInitialized) {
                            wellsInitialized = true;
                            await loadWells().catch(() => { wellsInitialized = false; });
                        }
                        loadTools();
                    }
                });
            });
            
            // Tab Visibility API - Auto-refresh when returning to tab
            document.addEventListener('visibilitychange', async () => {
                if (!document.hidden && currentTab === 'documents' && documentsInitialized) {
                    // User returned to tab while on documents
                    const hasProcessing = loadedDocuments.some(doc => 
                        doc.status === 'processing' || doc.status === 'pending'
                    );
                    if (hasProcessing) {
                        console.log('[Documents] Tab became visible with processing documents, refreshing...');
                        await loadDocuments();
                    }
                }
            });
            
            // Bulk selection event listeners
            document.addEventListener('change', (e) => {
                // Handle select all checkboxes
                if (e.target.id === 'selectAllProperties') {
                    selectAllItems('properties', e.target.checked);
                } else if (e.target.id === 'selectAllWells') {
                    selectAllItems('wells', e.target.checked);
                }
                // Handle individual checkboxes
                else if (e.target.classList.contains('property-checkbox')) {
                    togglePropertySelection(e.target.dataset.id, e.target.checked);
                } else if (e.target.classList.contains('well-checkbox')) {
                    toggleWellSelection(e.target.dataset.id, e.target.checked);
                } else if (e.target.classList.contains('document-checkbox')) {
                    toggleDocumentSelection(e.target.dataset.id, e.target.checked);
                }
            });

            // Shift+click range selection for all bulk checkbox lists
            initShiftSelect(
                document, '.property-checkbox',
                () => Array.from(document.querySelectorAll('.property-checkbox')),
                (indices, checked) => {
                    const cbs = Array.from(document.querySelectorAll('.property-checkbox'));
                    for (const i of indices) {
                        const id = cbs[i].dataset.id;
                        if (checked) selectedProperties.add(id); else selectedProperties.delete(id);
                    }
                    updateBulkActionVisibility();
                    updateSelectAllState('properties');
                }
            );
            initShiftSelect(
                document, '.well-checkbox',
                () => Array.from(document.querySelectorAll('.well-checkbox')),
                (indices, checked) => {
                    const cbs = Array.from(document.querySelectorAll('.well-checkbox'));
                    for (const i of indices) {
                        const id = cbs[i].dataset.id;
                        if (checked) selectedWells.add(id); else selectedWells.delete(id);
                    }
                    updateBulkActionVisibility();
                    updateSelectAllState('wells');
                }
            );
            initShiftSelect(
                document, '.document-checkbox',
                () => Array.from(document.querySelectorAll('.document-checkbox')),
                (indices, checked) => {
                    const cbs = Array.from(document.querySelectorAll('.document-checkbox'));
                    for (const i of indices) {
                        const id = cbs[i].dataset.id;
                        if (checked) selectedDocuments.add(id); else selectedDocuments.delete(id);
                    }
                    updateBulkActionVisibility();
                }
            );
            
            // Add button event listeners inside DOMContentLoaded
            // Well Modal
            document.getElementById('addWellBtn').addEventListener('click', () => {
                const m = document.getElementById('addWellModal');
                m.style.display = 'flex';
                openModalA11y(m);
            });
            
            // Bulk Upload Properties Modal
            const bulkUploadBtn = document.getElementById('bulkUploadBtn');
            console.log('Bulk upload button:', bulkUploadBtn);
            if (bulkUploadBtn) {
                bulkUploadBtn.addEventListener('click', () => {
                    console.log('Import button clicked');
                    openBulkUploadModal();
                });
            } else {
                console.error('Bulk upload button not found!');
            }
            
            // Bulk Upload Wells Modal
            document.getElementById('bulkUploadWellsBtn').addEventListener('click', () => {
                openBulkUploadWellsModal();
            });
            
            // Add Well Modal event listeners
            document.getElementById('addWellModal').addEventListener('click', e => { 
                if (e.target.id === 'addWellModal') closeWellModal(); 
            });
            
            document.getElementById('addWellForm').addEventListener('submit', async e => {
                e.preventDefault();
                const data = { 
                    apiNumber: document.getElementById('apiNumber').value.trim(),
                    notes: document.getElementById('wellNotes').value.trim()
                };
                
                try {
                    document.querySelector('.btn-submit').disabled = true;
                    const res = await fetch('/api/wells/track', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    
                    if (!res.ok) {
                        const error = await res.json();
                        throw new Error(error.error || 'Failed to add well');
                    }
                    
                    const result = await res.json();
                    closeWellModal();
                    showToast('Well added successfully');
                    loadWells();
                    loadActivityStats();
                } catch (err) {
                    showToast('Error: ' + err.message, 'error');
                } finally {
                    document.querySelector('.btn-submit').disabled = false;
                }
            });
        });
        
        let wellsInitialized = false;
        let activityInitialized = false;
        let documentsInitialized = false;

        async function loadBarCounts() {
            try {
                const res = await fetch('/api/dashboard/counts');
                if (res.ok) {
                    const data = await res.json();
                    document.getElementById('wellCount').textContent = data.wells;
                    if (document.getElementById('docCount')) {
                        document.getElementById('docCount').textContent = data.documents;
                    }
                }
            } catch {}
        }

        async function loadAllData() {
            const promises = [loadProperties(), loadActivityStats(), loadBarCounts()];

            // Reload tabs that have already been initialized (for post-mutation refresh)
            if (wellsInitialized) promises.push(loadWells());
            if (activityInitialized) promises.push(loadActivity());
            if (documentsInitialized && document.getElementById('documentsTab') &&
                document.getElementById('documentsTab').style.display !== 'none') {
                promises.push(loadDocuments());
                promises.push(loadUsageStats());
            }

            await Promise.all(promises);
        }

        async function findWellMatches() {
            const wrapper = document.getElementById('findMatchesBtn');
            const btn = wrapper.querySelector('button');
            btn.disabled = true;
            const origText = btn.textContent;
            btn.textContent = 'Matching...';
            try {
                const res = await fetch('/api/match-property-wells', { method: 'POST' });
                const data = await res.json();
                if (data.success) {
                    const s = data.stats;
                    const count = s.linksCreated;
                    if (count > 0) {
                        // Build detail of new match types
                        const types = Object.entries(s.newMatchesByType || {}).map(([k,v]) => `${v} ${k}`).join(', ');
                        showToast(`Found ${count} new match${count === 1 ? '' : 'es'}: ${types}`, 'success');
                        await Promise.all([loadProperties(), loadWells()]);
                    } else {
                        showToast('All wells matched', 'info');
                    }
                } else {
                    showToast(data.error || 'Matching failed', 'error');
                }
            } catch (err) {
                showToast('Error: ' + err.message, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = origText;
            }
        }

        async function discoverAndTrackWells() {
            // Phase 1: Initial confirm with branded modal
            const confirmed = await showConfirm(
                'We\'ll search Oklahoma Corporation Commission records for producing wells in your property sections \u2014 including horizontal wells with laterals crossing through your land.<br><br>Wells that are already tracked will be skipped. You\'ll review the results before anything is added.',
                {
                    title: 'Scan for wells at your property locations?',
                    icon: '\uD83D\uDD0D',
                    iconBg: '#DBEAFE',
                    iconColor: '#2563EB',
                    confirmText: 'Scan Properties',
                    cancelText: 'Cancel',
                    confirmBtnClass: 'confirm-btn confirm-btn-discover'
                }
            );
            if (!confirmed) return;

            // Phase 2: Preview — scan with pulse animation
            const wrapper = document.getElementById('findMatchesBtn');
            const btn = wrapper ? wrapper.querySelector('button') : null;
            if (btn) {
                btn.disabled = true;
                btn.classList.add('discovering');
                btn.innerHTML = '<span class="discover-pulse-dot"></span> Discovering...';
            }

            let previewData;
            try {
                const res = await fetch('/api/discover-and-track-wells?preview=true', { method: 'POST' });
                previewData = await res.json();
                if (!res.ok) {
                    showToast(previewData.error || 'Discovery failed', 'error');
                    return;
                }
            } catch (err) {
                showToast('Error: ' + err.message, 'error');
                return;
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.classList.remove('discovering');
                    btn.textContent = 'Discover & Track Wells';
                }
            }

            // Phase 3: Results modal (or toast if nothing found)
            if (!previewData.success || !previewData.wells || previewData.wells.length === 0) {
                if (previewData.stats?.wellsSkipped > 0) {
                    showToast(`All ${previewData.stats.wellsSkipped} discovered wells are already tracked.`, 'info');
                } else {
                    showToast('No producing wells found at your property locations.', 'info');
                }
                return;
            }

            const selectedApis = await showDiscoverResultsModal(previewData);
            if (!selectedApis || selectedApis.length === 0) return;

            // Phase 4: Commit selected wells
            if (btn) {
                btn.disabled = true;
                btn.classList.add('discovering');
                btn.innerHTML = `<span class="discover-pulse-dot"></span> Adding ${selectedApis.length} well${selectedApis.length === 1 ? '' : 's'}...`;
            }

            try {
                const res = await fetch('/api/discover-and-track-wells', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apiNumbers: selectedApis })
                });
                const data = await res.json();
                if (!res.ok) {
                    showToast(data.error || 'Failed to add wells', 'error');
                    return;
                }
                if (data.success) {
                    const s = data.stats;
                    let msg = `Added ${s.wellsTracked} well${s.wellsTracked === 1 ? '' : 's'} and created ${s.linksCreated} link${s.linksCreated === 1 ? '' : 's'}`;
                    if (s.wellsSkipped > 0) msg += ` (${s.wellsSkipped} already tracked)`;
                    showToast(msg, 'success', 6000);
                    // Switch to Recently Added sort so new wells appear first
                    const sortSelect = document.getElementById('wellsSort');
                    if (sortSelect) {
                        sortSelect.value = 'date-desc';
                        if (typeof wellsController !== 'undefined') wellsController.sortBy = 'date-desc';
                    }
                    await loadAllData();
                } else {
                    showToast(data.error || 'Failed to add wells', 'error');
                }
            } catch (err) {
                showToast('Error: ' + err.message, 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.classList.remove('discovering');
                    btn.textContent = 'Discover & Track Wells';
                }
            }
        }

        /**
         * Shows the discover results modal with virtual-scrolled selectable well list.
         * Returns Promise<string[]> of selected API numbers, or [] if cancelled.
         */
        function showDiscoverResultsModal(previewData) {
            return new Promise((resolve) => {
                const overlay = document.getElementById('discoverResultsOverlay');
                const body = document.getElementById('discoverResultsBody');
                const cancelBtn = document.getElementById('discoverResultsCancel');
                const confirmBtn = document.getElementById('discoverResultsConfirm');
                if (!overlay || !body) { resolve([]); return; }

                const stats = previewData.stats;
                const wells = previewData.wells || [];
                const selected = new Set(wells.map(w => w.api));

                // Limit selection to plan remaining
                const maxSelectable = stats.remaining;
                if (selected.size > maxSelectable) {
                    const allApis = Array.from(selected);
                    selected.clear();
                    for (let i = 0; i < maxSelectable; i++) selected.add(allApis[i]);
                }

                // Group wells by match method
                const matchMethodLabels = { surface: 'Surface Match', bottom_hole: 'Bottom Hole Match', lateral_path: 'Lateral Path Match' };
                const matchMethodOrder = ['surface', 'bottom_hole', 'lateral_path'];
                const groups = new Map();
                for (const w of wells) {
                    const method = w.matchMethod || 'surface';
                    if (!groups.has(method)) groups.set(method, []);
                    groups.get(method).push(w);
                }
                // Sort groups by defined order
                const sortedGroups = matchMethodOrder.filter(m => groups.has(m)).map(m => [m, groups.get(m)]);

                // Build flat item array for virtual scroller
                const ROW_HEIGHT = 32;
                const HEADER_HEIGHT = 28;
                const BUFFER = 5;
                const flatItems = [];
                for (const [method, groupWells] of sortedGroups) {
                    flatItems.push({ type: 'header', groupKey: method, label: matchMethodLabels[method] || method, count: groupWells.length });
                    for (const w of groupWells) {
                        flatItems.push({ type: 'well', ...w });
                    }
                }

                function getItemHeight(item) {
                    return item.type === 'header' ? HEADER_HEIGHT : ROW_HEIGHT;
                }

                // Precompute cumulative offsets
                const offsets = [];
                let cumHeight = 0;
                for (const item of flatItems) {
                    offsets.push(cumHeight);
                    cumHeight += getItemHeight(item);
                }
                const totalHeight = cumHeight;

                function updateButtonState() {
                    const count = selected.size;
                    confirmBtn.disabled = count === 0;
                    confirmBtn.textContent = count > 0 ? `Add ${count} Well${count === 1 ? '' : 's'}` : 'Add Wells';
                }

                function getGroupSelectedCount(groupKey) {
                    const groupWells = groups.get(groupKey) || [];
                    return groupWells.filter(w => selected.has(w.api)).length;
                }

                const matchBadgeMap = { surface: 'Surface', bottom_hole: 'Bottom Hole', lateral_path: 'Lateral' };

                function renderItem(item, top) {
                    if (item.type === 'header') {
                        const selCount = getGroupSelectedCount(item.groupKey);
                        return `<div class="discover-vrow-header" style="top:${top}px;height:${HEADER_HEIGHT}px;">
                            <span>${escapeHtml(item.label)}</span>
                            <span class="discover-group-count">(${selCount} of ${item.count} selected)</span>
                        </div>`;
                    }
                    const checked = selected.has(item.api) ? ' checked' : '';
                    const badge = matchBadgeMap[item.matchMethod] || 'Surface';
                    const badgeClass = item.matchMethod === 'bottom_hole' ? 'bottom-hole' : (item.matchMethod || 'surface');
                    return `<div class="discover-vrow" style="top:${top}px;height:${ROW_HEIGHT}px;">
                        <input type="checkbox" class="discover-well-check" data-api="${item.api}"${checked}>
                        <span class="discover-well-name" title="${escapeHtml(item.name)}">${escapeHtml(item.name)}</span>
                        <span class="discover-well-operator" title="${escapeHtml(item.operator)}">${escapeHtml(item.operator)}</span>
                        <span class="discover-well-county">${escapeHtml(item.county || '')}</span>
                        <span class="match-badge ${badgeClass}">${badge}</span>
                    </div>`;
                }

                // Build stats summary
                let statsHtml = `<div class="discover-stats">
                    <span class="discover-stat">${wells.length} new</span>
                    <span class="discover-stat">${stats.wellsSkipped || 0} already tracked</span>
                    <span class="discover-stat">${stats.propertiesScanned} properties scanned</span>
                </div>`;
                if (stats.wellsOverLimit > 0) {
                    statsHtml += `<div class="discover-limit-warn">Your ${stats.plan} plan allows ${stats.wellLimit} wells. You have ${stats.currentWells} tracked. Only ${stats.remaining} more can be added.</div>`;
                }

                // Build body HTML
                body.innerHTML = `
                    ${statsHtml}
                    <div class="discover-select-all">
                        <label><input type="checkbox" id="discoverSelectAll" checked> <span id="discoverSelectLabel">${selected.size} of ${wells.length} selected</span></label>
                    </div>
                    <div class="discover-vscroll" id="discoverVscroll">
                        <div class="discover-vscroll-spacer" style="height:${totalHeight}px;"></div>
                        <div class="discover-vscroll-content" id="discoverVscrollContent"></div>
                    </div>
                `;

                const vscroll = document.getElementById('discoverVscroll');
                const vscrollContent = document.getElementById('discoverVscrollContent');
                const selectAllCb = document.getElementById('discoverSelectAll');
                const selectLabel = document.getElementById('discoverSelectLabel');

                function updateSelectLabel() {
                    if (selectLabel) selectLabel.textContent = `${selected.size} of ${wells.length} selected`;
                    if (selectAllCb) selectAllCb.checked = selected.size === wells.length;
                    if (selectAllCb) selectAllCb.indeterminate = selected.size > 0 && selected.size < wells.length;
                }

                let lastStart = -1, lastEnd = -1;
                function renderVisible() {
                    if (!vscroll || !vscrollContent) return;
                    const scrollTop = vscroll.scrollTop;
                    const viewHeight = vscroll.clientHeight;

                    // Binary search for start index
                    let lo = 0, hi = flatItems.length - 1;
                    while (lo < hi) {
                        const mid = (lo + hi) >> 1;
                        if (offsets[mid] + getItemHeight(flatItems[mid]) < scrollTop) lo = mid + 1;
                        else hi = mid;
                    }
                    let startIdx = Math.max(0, lo - BUFFER);
                    let endIdx = lo;
                    // Find end index
                    while (endIdx < flatItems.length && offsets[endIdx] < scrollTop + viewHeight) endIdx++;
                    endIdx = Math.min(flatItems.length - 1, endIdx + BUFFER);

                    if (startIdx === lastStart && endIdx === lastEnd) return;
                    lastStart = startIdx;
                    lastEnd = endIdx;

                    let html = '';
                    for (let i = startIdx; i <= endIdx; i++) {
                        html += renderItem(flatItems[i], offsets[i]);
                    }
                    vscrollContent.innerHTML = html;
                }

                renderVisible();

                // Event handlers
                function onScroll() { renderVisible(); }
                vscroll.addEventListener('scroll', onScroll);

                // Build API→flatIndex lookup for shift+click (only well items, skip headers)
                const apiToFlatIndex = new Map();
                for (let i = 0; i < flatItems.length; i++) {
                    if (flatItems[i].type === 'well') apiToFlatIndex.set(flatItems[i].api, i);
                }
                let lastClickedFlatIdx = -1;

                function onCheckboxClick(e) {
                    const cb = e.target.closest('.discover-well-check');
                    if (!cb) return;
                    const api = cb.dataset.api;
                    const currentFlatIdx = apiToFlatIndex.get(api) ?? -1;

                    // Shift+click range selection
                    if (e.shiftKey && lastClickedFlatIdx !== -1 && currentFlatIdx !== -1 && lastClickedFlatIdx !== currentFlatIdx) {
                        e.preventDefault();
                        const rangeStart = Math.min(lastClickedFlatIdx, currentFlatIdx);
                        const rangeEnd = Math.max(lastClickedFlatIdx, currentFlatIdx);
                        const checked = cb.checked;
                        for (let i = rangeStart; i <= rangeEnd; i++) {
                            const item = flatItems[i];
                            if (item.type !== 'well') continue;
                            if (checked) {
                                if (selected.size >= maxSelectable) break;
                                selected.add(item.api);
                            } else {
                                selected.delete(item.api);
                            }
                        }
                        lastClickedFlatIdx = currentFlatIdx;
                        updateSelectLabel();
                        updateButtonState();
                        lastStart = -1; lastEnd = -1;
                        renderVisible();
                        return;
                    }

                    // Normal single click
                    if (cb.checked) {
                        if (selected.size >= maxSelectable) {
                            cb.checked = false;
                            showToast(`Plan limit: only ${maxSelectable} wells can be added`, 'warning');
                            return;
                        }
                        selected.add(api);
                    } else {
                        selected.delete(api);
                    }
                    lastClickedFlatIdx = currentFlatIdx;
                    updateSelectLabel();
                    updateButtonState();
                    // Re-render to update group counts
                    lastStart = -1; lastEnd = -1;
                    renderVisible();
                }
                // Use click (not change) to detect shiftKey
                vscrollContent.addEventListener('click', onCheckboxClick);

                function onSelectAll() {
                    if (selectAllCb.checked) {
                        const toAdd = wells.slice(0, maxSelectable);
                        selected.clear();
                        for (const w of toAdd) selected.add(w.api);
                    } else {
                        selected.clear();
                    }
                    updateSelectLabel();
                    updateButtonState();
                    lastStart = -1; lastEnd = -1;
                    renderVisible();
                }
                selectAllCb.addEventListener('change', onSelectAll);

                updateButtonState();

                // Show modal
                overlay.classList.add('show');
                openModalA11y(overlay);

                function cleanup() {
                    vscroll.removeEventListener('scroll', onScroll);
                    vscrollContent.removeEventListener('click', onCheckboxClick);
                    selectAllCb.removeEventListener('change', onSelectAll);
                    cancelBtn.removeEventListener('click', onCancel);
                    confirmBtn.removeEventListener('click', onConfirm);
                    overlay.removeEventListener('click', onOverlayClick);
                    closeModalA11y(overlay);
                    overlay.classList.remove('show');
                }

                function onCancel() { cleanup(); resolve([]); }
                function onConfirm() { cleanup(); resolve(Array.from(selected)); }
                function onOverlayClick(e) { if (e.target === overlay) onCancel(); }

                cancelBtn.addEventListener('click', onCancel);
                confirmBtn.addEventListener('click', onConfirm);
                overlay.addEventListener('click', onOverlayClick);
            });
        }


