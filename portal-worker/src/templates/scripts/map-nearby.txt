        // Color by operator state
        let colorByOperator = false;
        let operatorColorMap = {};

        // Generate a distinct color for any operator using hash
        function hashOperatorColor(name) {
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            // Use golden ratio to spread hues evenly
            const hue = ((hash & 0xFFFFFF) * 137.508) % 360;
            return `hsl(${Math.round(hue)}, 70%, 50%)`;
        }

        // Build operator color map from well data
        function buildOperatorColorMap(wells) {
            const counts = {};
            wells.forEach(w => {
                const op = (w.operator || 'Unknown').toUpperCase().trim();
                counts[op] = (counts[op] || 0) + 1;
            });
            // Sort by count descending
            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
            const map = {};
            // Top operators get manually-assigned vibrant colors for best distinction
            const palette = [
                '#1E40AF', '#DC2626', '#059669', '#7C3AED', '#F59E0B',
                '#0891B2', '#EC4899', '#84CC16', '#F97316', '#06B6D4',
                '#8B5CF6', '#10B981', '#EF4444', '#6366F1', '#14B8A6',
                '#F43F5E', '#A855F7', '#22C55E', '#E11D48', '#0EA5E9'
            ];
            sorted.forEach(([op, count], i) => {
                map[op] = i < palette.length ? palette[i] : hashOperatorColor(op);
            });
            return map;
        }

        function toggleColorByOperator() {
            colorByOperator = !colorByOperator;
            const btn = document.getElementById('colorByOperatorBtn');
            if (btn) {
                if (colorByOperator) btn.classList.add('active');
                else btn.classList.remove('active');
            }
            // Re-render with existing data
            if (allNearbyWells && allNearbyWells.length > 0) {
                const filteredWells = filterWellsData(allNearbyWells);
                displayFilteredWells(filteredWells);
            }
        }

        // Toggle nearby wells from D1 database
        function toggleNearbyWells() {
            console.log('toggleNearbyWells called');
            const select = document.getElementById('nearby-wells-select');
            const value = select.value;
            const countDiv = document.getElementById('nearbyWellsCount');
            const separatorDiv = document.getElementById('nearbyWellsSeparator');

            console.log('Nearby wells select value:', value);
            console.log('User properties count:', userProperties.length);

            const opBtn = document.getElementById('colorByOperatorBtn');

            // Update active state based on selection
            if (value !== 'off') {
                select.classList.add('active');
                if (countDiv) countDiv.style.display = 'flex';
                if (separatorDiv) separatorDiv.style.display = 'block';
                if (opBtn) opBtn.style.display = '';
                console.log('Calling loadNearbyWells...');
                loadNearbyWells();
            } else {
                select.classList.remove('active');
                if (nearbyWellsLayer && map.hasLayer(nearbyWellsLayer)) {
                    map.removeLayer(nearbyWellsLayer);
                }
                if (nearbyLateralsLayer && map.hasLayer(nearbyLateralsLayer)) {
                    map.removeLayer(nearbyLateralsLayer);
                }
                if (countDiv) countDiv.style.display = 'none';
                if (separatorDiv) separatorDiv.style.display = 'none';
                if (opBtn) opBtn.style.display = 'none';
                // Remove operator legend
                removeOperatorLegend();
                const filterPanel = document.getElementById('wellsFilterPanel');
                if (filterPanel) filterPanel.style.display = 'none';
                const wellCount = document.getElementById('nearbyWellCount');
                if (wellCount) wellCount.textContent = '0';
                // Remove nearby wells from search index
                updateSearchIndex();
            }
        }


        // Helper function to generate cache key
        function getWellsCacheKey(status) {
            // Include a hash of property IDs to invalidate when properties change
            const propertyIds = userProperties.map(p => p.id).sort().join(',');
            const propertyHash = btoa(propertyIds).substring(0, 8); // Short hash
            // Add version number to invalidate old caches
            const CACHE_VERSION = 'v9'; // Fixed nearby-wells to query one TRS at a time
            return `mw_nearby_wells_${status}_${propertyHash}_${CACHE_VERSION}`;
        }

        // Helper function to clear all nearby wells caches
        function clearNearbyWellsCache() {
            const keys = Object.keys(localStorage).filter(k => k.includes('mw_nearby_wells'));
            keys.forEach(k => localStorage.removeItem(k));
            console.log(`Cleared ${keys.length} nearby wells cache entries`);
        }

        // Make it available globally for debugging
        window.clearNearbyWellsCache = clearNearbyWellsCache;

        // Helper function to show loading overlay on map
        function showMapLoadingOverlay(message = 'Loading...') {
            // Show a lightweight loading indicator for nearby wells select
            const select = document.getElementById('nearby-wells-select');
            if (select) {
                select.classList.add('loading');
                select.classList.add('active'); // Keep orange styling
                // Store original option text and change to Loading...
                const selectedOption = select.options[select.selectedIndex];
                select.setAttribute('data-original-text', selectedOption.text);
                selectedOption.text = 'Loading...';
            }
        }

        function hideMapLoadingOverlay() {
            // Remove loading state from nearby wells select
            const select = document.getElementById('nearby-wells-select');
            if (select) {
                select.classList.remove('loading');
                // Restore original option text
                const originalText = select.getAttribute('data-original-text');
                if (originalText) {
                    select.options[select.selectedIndex].text = originalText;
                    select.removeAttribute('data-original-text');
                }
            }
        }

        // Load wells from D1 database based on user properties (3x3 sections)
        async function loadNearbyWells() {
            console.log('loadNearbyWells started');
            console.log('userProperties:', userProperties);

            // Ensure we have user properties
            if (!userProperties || userProperties.length === 0) {
                console.error('No user properties loaded yet');
                updateStatus('No properties found - please refresh the page');
                return;
            }

            try {
                // Get status filter from the dropdown
                const statusFilter = document.getElementById('nearby-wells-select').value;
                console.log('Status filter value:', statusFilter);
                if (statusFilter === 'off') {
                    console.log('Nearby wells is off, not loading');
                    return;
                }
                // PRODUCING uses AC on the API side, then filters client-side
                const apiStatus = statusFilter === 'PRODUCING' ? 'AC' : statusFilter;
                const statusText = statusFilter === 'AC' ? 'active' : statusFilter === 'PRODUCING' ? 'producing' : 'all';
                const cacheKey = getWellsCacheKey(statusFilter);

                // Check cache first
                const cachedData = localStorage.getItem(cacheKey);
                if (cachedData) {
                    try {
                        const cached = JSON.parse(cachedData);
                        const cacheAge = Date.now() - cached.timestamp;
                        const MAX_CACHE_AGE = 24 * 60 * 60 * 1000; // 24 hours

                        // Don't use cache if it's empty or too old
                        if (cacheAge < MAX_CACHE_AGE && cached.wells && cached.wells.length > 0) {
                            console.log(`Using cached ${statusText} wells data (${Math.round(cacheAge / 1000 / 60)} minutes old)`);
                            allNearbyWells = cached.wells;
                            const filteredWells = filterWellsData(cached.wells);
                            displayFilteredWells(filteredWells);
                            updateStatus(`Displayed ${cached.wells.length} ${statusText} wells (from cache)`);
                            return;
                        } else if (cached.wells && cached.wells.length === 0) {
                            console.log('Cache contains 0 wells, invalidating and fetching fresh data');
                            localStorage.removeItem(cacheKey);
                        }
                    } catch (e) {
                        console.error('Failed to parse cached data:', e);
                        localStorage.removeItem(cacheKey);
                    }
                }

                // Show loading overlay
                showMapLoadingOverlay(`Loading ${statusText} wells...`);
                updateStatus('Loading nearby wells...');

                // Get TRS sections for all user properties ‚Äî 3x3 core + 5x5 extended in one pass
                const propertySections = await getPropertyNearbySections();

                if (propertySections.length === 0) {
                    hideMapLoadingOverlay();
                    updateStatus('No properties found');
                    return;
                }

                // Build combined TRS set: 3x3 core + 5x5 outer ring (for long laterals)
                const coreSections = new Set(propertySections);
                const extendedOnlySections = new Set();

                for (const property of userProperties) {
                    const fields = property.fields || property;
                    const section = parseInt(fields.SEC || fields.Section);
                    let township = (fields.TWN || fields.Township || '').replace(/\s+/g, '').toUpperCase();
                    let range = (fields.RNG || fields.Range || '').replace(/\s+/g, '').toUpperCase();
                    township = township.replace(/^T/, '');
                    range = range.replace(/^R/, '');
                    const meridian = fields.MERIDIAN || 'IM';

                    if (section && township && range) {
                        const extendedNearbySections = get5x5Sections(section, township, range, meridian);
                        extendedNearbySections.forEach(trs => {
                            if (!coreSections.has(trs)) {
                                extendedOnlySections.add(trs);
                            }
                        });
                    }
                }

                // Single API call with all sections (core + extended)
                const allSections = [...propertySections, ...extendedOnlySections];
                console.log(`Loading ${statusText} wells: ${propertySections.length} core + ${extendedOnlySections.size} extended = ${allSections.length} sections`);

                const response = await fetch('/api/nearby-wells', {
                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        trs: allSections,
                        status: apiStatus.toLowerCase(),
                        limit: 25000
                    })
                });

                if (!response.ok) {
                    hideMapLoadingOverlay();
                    console.error('Failed to load wells:', response.status);
                    updateStatus('Failed to load wells');
                    return;
                }

                const result = await response.json();
                const allWells = result.data?.wells || [];
                console.log(`Received ${allWells.length} wells in ${result.data?.query?.executionTime}ms`);

                // Tag wells from extended-only sections as extended laterals
                // (only keep them if they have long laterals > 1 mile with BH coords)
                const filteredAllWells = allWells.filter(well => {
                    const trs = `${well.section}-${well.township}-${well.range}-${well.meridian}`;
                    if (extendedOnlySections.has(trs)) {
                        if (well.lateral_length && well.lateral_length > 5280 &&
                            well.bh_latitude && well.bh_longitude) {
                            well.isExtendedLateral = true;
                            return true;
                        }
                        return false; // Drop non-lateral wells from extended ring
                    }
                    return true; // Keep all core wells
                });

                // Remove duplicates
                let uniqueWells = Array.from(
                    new Map(filteredAllWells.map(w => [w.api_number, w])).values()
                );
                // If "Producing" filter, remove wells without recent production
                if (statusFilter === 'PRODUCING') {
                    // Compute cutoff from data in this batch
                    const prodMonths = uniqueWells.map(w => w.last_prod_month).filter(Boolean).sort();
                    if (prodMonths.length > 0) {
                        let horizon = prodMonths[prodMonths.length - 1];
                        const mc = {};
                        prodMonths.forEach(m => { mc[m] = (mc[m] || 0) + 1; });
                        const sorted = Object.entries(mc).sort((a, b) => b[0].localeCompare(a[0]));
                        for (const [month, count] of sorted) {
                            if (count >= 10) { horizon = month; break; }
                        }
                        let cy = parseInt(horizon.substring(0, 4));
                        let cm = parseInt(horizon.substring(4, 6)) - 3;
                        if (cm <= 0) { cm += 12; cy -= 1; }
                        const cutoff = '' + cy + String(cm).padStart(2, '0');
                        const before = uniqueWells.length;
                        uniqueWells = uniqueWells.filter(w => w.last_prod_month && w.last_prod_month >= cutoff);
                        console.log(`Producing filter: ${before} ‚Üí ${uniqueWells.length} (cutoff ${cutoff})`);
                    }
                }

                console.log(`${uniqueWells.length} unique wells after filtering`);

                // Cache the results
                try {
                    localStorage.setItem(cacheKey, JSON.stringify({
                        wells: uniqueWells,
                        timestamp: Date.now()
                    }));
                } catch (e) {
                    // Clear old cache if storage is full
                    try {
                        Object.keys(localStorage).filter(k => k.startsWith('mw_nearby_wells_')).forEach(k => {
                            localStorage.removeItem(k);
                        });
                    } catch (clearError) { /* ignore */ }
                }

                // Store wells for filtering
                allNearbyWells = uniqueWells;

                // Display wells (respecting any active filters)
                const filteredWells = filterWellsData(uniqueWells);
                console.log(`After filtering: ${filteredWells.length} wells to display`);
                displayFilteredWells(filteredWells);

                // Hide loading indicator after wells are displayed
                hideMapLoadingOverlay();

                // Update status
                if (filteredWells.length < uniqueWells.length) {
                    const filterCount = Object.values(wellsFilterState).filter(v => v).length;
                    updateStatus(`Loaded ${uniqueWells.length} wells, showing ${filteredWells.length} (${filterCount} filters active)`);
                } else {
                    updateStatus(`Loaded ${uniqueWells.length} wells from D1 database`);
                }

                // Clear status after delay
                setTimeout(() => updateStatus('Map ready'), 3000);

            } catch (error) {
                console.error('Error loading nearby wells:', error);
                hideMapLoadingOverlay();
                updateStatus('Failed to load wells');
                setTimeout(() => updateStatus('Map ready'), 3000);
            }
        }

        // Get 3x3 sections around user properties
        async function getPropertyNearbySections() {
            const sectionsSet = new Set();

            // For each property, get its section and 3x3 neighbors
            for (const property of userProperties) {
                const fields = property.fields || property;

                // Get property TRS
                const section = parseInt(fields.SEC || fields.Section);
                let township = (fields.TWN || fields.Township || '').replace(/\s+/g, '').toUpperCase();
                let range = (fields.RNG || fields.Range || '').replace(/\s+/g, '').toUpperCase();

                // Remove S/T/R prefixes if present
                township = township.replace(/^T/, '');
                range = range.replace(/^R/, '');

                // Get meridian - default to IM unless property has CM
                const meridian = fields.MERIDIAN || 'IM';

                // Log raw values for debugging
                console.log(`Property ${property.id}: Raw TWN="${fields.TWN || fields.Township}", RNG="${fields.RNG || fields.Range}", MERIDIAN="${meridian}"`);
                console.log(`Property ${property.id}: Parsed section=${section}, township=${township}, range=${range}, meridian=${meridian}`);

                if (!section || !township || !range) {
                    console.warn(`Property ${property.id} skipped - missing TRS data`);
                    continue;
                }

                // Get 3x3 sections around this property with proper meridian
                const nearbySections = get3x3Sections(section, township, range, meridian);
                nearbySections.forEach(trs => sectionsSet.add(trs));
            }

            return Array.from(sectionsSet);
        }

        // Get 3x3 grid of sections centered on given section
        function get3x3Sections(centerSection, township, range, meridian = 'IM') {
            const sections = [];

            // Standard 6x6 section layout
            const sectionGrid = [
                [6,  5,  4,  3,  2,  1],
                [7,  8,  9,  10, 11, 12],
                [18, 17, 16, 15, 14, 13],
                [19, 20, 21, 22, 23, 24],
                [30, 29, 28, 27, 26, 25],
                [31, 32, 33, 34, 35, 36]
            ];

            // Find center section position
            let centerRow = -1, centerCol = -1;
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 6; col++) {
                    if (sectionGrid[row][col] === centerSection) {
                        centerRow = row;
                        centerCol = col;
                        break;
                    }
                }
            }

            if (centerRow === -1) return [`${centerSection}-${township}-${range}-${meridian}`];

            // Get 3x3 grid (1 section in each direction)
            for (let row = Math.max(0, centerRow - 1); row <= Math.min(5, centerRow + 1); row++) {
                for (let col = Math.max(0, centerCol - 1); col <= Math.min(5, centerCol + 1); col++) {
                    const section = sectionGrid[row][col];
                    sections.push(`${section}-${township}-${range}-${meridian}`);
                }
            }

            return sections;
        }

        // Get 5x5 grid of sections centered on given section (for extended lateral search)
        function get5x5Sections(centerSection, township, range, meridian = 'IM') {
            const sections = [];

            // Standard 6x6 section layout
            const sectionGrid = [
                [6,  5,  4,  3,  2,  1],
                [7,  8,  9,  10, 11, 12],
                [18, 17, 16, 15, 14, 13],
                [19, 20, 21, 22, 23, 24],
                [30, 29, 28, 27, 26, 25],
                [31, 32, 33, 34, 35, 36]
            ];

            // Find center section position
            let centerRow = -1, centerCol = -1;
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 6; col++) {
                    if (sectionGrid[row][col] === centerSection) {
                        centerRow = row;
                        centerCol = col;
                        break;
                    }
                }
            }

            if (centerRow === -1) return [`${centerSection}-${township}-${range}-${meridian}`];

            // Get 5x5 grid (2 sections in each direction)
            for (let row = Math.max(0, centerRow - 2); row <= Math.min(5, centerRow + 2); row++) {
                for (let col = Math.max(0, centerCol - 2); col <= Math.min(5, centerCol + 2); col++) {
                    const section = sectionGrid[row][col];
                    sections.push(`${section}-${township}-${range}-${meridian}`);
                }
            }

            return sections;
        }

        // Parse PLSS ID to extract township/range
        function parsePlssId(plssId) {
            if (!plssId) return null;

            // Format: "OK170230N0080W0"
            const match = plssId.match(/OK\d{2}(\d{3})([NS])(\d{3})([EW])/);
            if (match) {
                const twpNum = parseInt(match[1], 10);
                const twpDir = match[2];
                const rngNum = parseInt(match[3], 10);
                const rngDir = match[4];

                return {
                    township: `${twpNum}${twpDir}`,
                    range: `${rngNum}${rngDir}`
                };
            }

            return null;
        }

        // No automatic refresh on map move - wells are loaded based on properties only

        // Wells filter state
        let wellsFilterState = {
            status: '',
            type: '',
            operator: '',
            county: ''
        };

        // All wells data (before filtering)
        let allNearbyWells = [];

        // Filter wells data based on current filter state
        function filterWellsData(wells) {
            return wells.filter(well => {
                // Status filter
                if (wellsFilterState.status && well.well_status !== wellsFilterState.status) {
                    return false;
                }

                // Type filter
                if (wellsFilterState.type && well.well_type !== wellsFilterState.type) {
                    return false;
                }

                // Operator filter (partial match)
                if (wellsFilterState.operator && !well.operator?.toLowerCase().includes(wellsFilterState.operator)) {
                    return false;
                }

                // County filter (partial match)
                if (wellsFilterState.county && !well.county?.toLowerCase().includes(wellsFilterState.county)) {
                    return false;
                }

                return true;
            });
        }

        // Toggle wells filter panel
        function toggleWellsFilter() {
            const panel = document.getElementById('wellsFilterPanel');
            const button = document.getElementById('filterToggleBtn');

            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                button.classList.add('active');
            } else {
                panel.style.display = 'none';
                button.classList.remove('active');
            }
        }

        // Apply wells filter
        function applyWellsFilter() {
            // Get filter values
            wellsFilterState.status = document.getElementById('filterWellStatus').value;
            wellsFilterState.type = document.getElementById('filterWellType').value;
            wellsFilterState.operator = document.getElementById('filterOperator').value.toLowerCase();
            wellsFilterState.county = document.getElementById('filterCounty').value.toLowerCase();

            // Filter wells
            const filteredWells = allNearbyWells.filter(well => {
                // Status filter
                if (wellsFilterState.status && well.well_status !== wellsFilterState.status) {
                    return false;
                }

                // Type filter
                if (wellsFilterState.type && well.well_type !== wellsFilterState.type) {
                    return false;
                }

                // Operator filter (partial match)
                if (wellsFilterState.operator && !well.operator?.toLowerCase().includes(wellsFilterState.operator)) {
                    return false;
                }

                // County filter (partial match)
                if (wellsFilterState.county && !well.county?.toLowerCase().includes(wellsFilterState.county)) {
                    return false;
                }

                return true;
            });

            // Update map
            displayFilteredWells(filteredWells);

            // Update status
            const filterCount = Object.values(wellsFilterState).filter(v => v).length;
            if (filterCount > 0) {
                updateStatus(`Showing ${filteredWells.length} of ${allNearbyWells.length} wells (${filterCount} filters active)`);
                document.getElementById('filterToggleBtn').innerHTML = '<span>üîç Filter Wells (' + filterCount + ')</span>';
            } else {
                updateStatus(`Showing all ${allNearbyWells.length} wells`);
                document.getElementById('filterToggleBtn').innerHTML = '<span>üîç Filter Wells</span>';
            }

            // Close panel
            toggleWellsFilter();
        }

        // Clear wells filter
        function clearWellsFilter() {
            // Reset form
            document.getElementById('filterWellStatus').value = '';
            document.getElementById('filterWellType').value = '';
            document.getElementById('filterOperator').value = '';
            document.getElementById('filterCounty').value = '';

            // Reset state
            wellsFilterState = {
                status: '',
                type: '',
                operator: '',
                county: ''
            };

            // Show all wells
            displayFilteredWells(allNearbyWells);
            updateStatus(`Showing all ${allNearbyWells.length} wells`);
            document.getElementById('filterToggleBtn').innerHTML = '<span>üîç Filter Wells</span>';

            // Close panel
            toggleWellsFilter();
        }

        // Display filtered wells on map
        function displayFilteredWells(wells) {
            // Initialize cluster group if not already done
            if (!nearbyWellsLayer) {
                nearbyWellsLayer = L.markerClusterGroup({
                    disableClusteringAtZoom: 13,  // Keep clustering until township-level zoom
                    maxClusterRadius: 80,
                    spiderfyOnMaxZoom: true,
                    showCoverageOnHover: false,
                    zoomToBoundsOnClick: true,
                    chunkedLoading: true,          // Non-blocking ‚Äî prevents UI freeze with thousands of markers
                    chunkInterval: 100,
                    chunkDelay: 10,
                    iconCreateFunction: function(cluster) {
                        const count = cluster.getChildCount();
                        let className = 'marker-cluster-small';

                        if (count > 100) {
                            className = 'marker-cluster-large';
                        } else if (count > 25) {
                            className = 'marker-cluster-medium';
                        }

                        return new L.DivIcon({
                            html: '<div><span>' + count + '</span></div>',
                            className: 'marker-cluster ' + className,
                            iconSize: new L.Point(40, 40)
                        });
                    }
                });
            }

            // Clear existing wells
            nearbyWellsLayer.clearLayers();

            // Build set of tracked well API numbers for fast lookup
            const trackedAPIs = new Set();
            if (trackedWells && trackedWells.length > 0) {
                trackedWells.forEach(well => {
                    if (well.apiNumber) {
                        trackedAPIs.add(well.apiNumber);
                    }
                });
                console.log(`Filtering out ${trackedAPIs.size} tracked wells from nearby wells display`);
            }

            // Filter out tracked wells
            const untracked = wells.filter(well => {
                return !trackedAPIs.has(well.api_number);
            });

            console.log(`Displaying ${untracked.length} untracked wells (filtered ${wells.length - untracked.length} tracked wells)`);
            wells = untracked;

            // Update nearby wells count
            document.getElementById('nearbyWellCount').textContent = wells.length;

            // Build operator color map if in operator mode
            if (colorByOperator) {
                operatorColorMap = buildOperatorColorMap(wells);
                renderOperatorLegend();
                // Attach viewport handler so legend updates on pan/zoom
                if (!window._operatorLegendHandler) {
                    window._operatorLegendHandler = function() {
                        cachedFilingCounts = null; // Invalidate on viewport change
                        renderOperatorLegend();
                        if (legendMode === 'filings') fetchAreaFilings();
                    };
                    map.on('moveend zoomend', window._operatorLegendHandler);
                }
            } else {
                removeOperatorLegend();
            }

            // Store wells data globally for popup access
            window.nearbyWellsData = {};

            // Collect lateral data separately ‚Äî drawn only when zoomed in
            const lateralData = [];

            // Compute production data horizon from nearby wells (same logic as dashboard)
            let nearbyProdHorizon = null;
            const allProdMonths = wells.map(w => w.last_prod_month).filter(Boolean).sort();
            if (allProdMonths.length > 0) {
                // Use the most recent month with substantial data
                const monthCounts = {};
                allProdMonths.forEach(m => { monthCounts[m] = (monthCounts[m] || 0) + 1; });
                const sorted = Object.entries(monthCounts).sort((a, b) => b[0].localeCompare(a[0]));
                // Pick the first month with at least 10 wells (or just the latest)
                nearbyProdHorizon = sorted[0][0];
                for (const [month, count] of sorted) {
                    if (count >= 10) { nearbyProdHorizon = month; break; }
                }
            }
            // 3 months before horizon
            let nearbyProdCutoff = null;
            if (nearbyProdHorizon) {
                let y = parseInt(nearbyProdHorizon.substring(0, 4));
                let m = parseInt(nearbyProdHorizon.substring(4, 6)) - 3;
                if (m <= 0) { m += 12; y -= 1; }
                nearbyProdCutoff = '' + y + String(m).padStart(2, '0');
            }

            // Check if a well is actively producing
            function isProducing(well) {
                if (!well.last_prod_month || !nearbyProdCutoff) return false;
                return well.last_prod_month >= nearbyProdCutoff;
            }

            // Determine marker color + glow based on well type, status, and production
            function nearbyMarkerStyle(well) {
                const isPlugged = well.well_status === 'PA';
                const producing = !isPlugged && isProducing(well);

                // Color by operator mode
                if (colorByOperator) {
                    const op = (well.operator || 'Unknown').toUpperCase().trim();
                    const color = operatorColorMap[op] || '#6B7280';
                    const glow = isPlugged ? 'none' : `0 0 6px 2px ${color}66`;
                    return { color, glow, opacity: isPlugged ? 0.4 : 1, producing };
                }

                const wt = (well.well_type || '').toLowerCase();
                let color, glow;
                if (wt.includes('gas')) {
                    color = isPlugged ? '#F87171' : '#EF4444';
                    glow = isPlugged ? 'none' : '0 0 6px 2px rgba(239,68,68,0.5)';
                } else if (wt.includes('injection') || wt.includes('swd')) {
                    color = isPlugged ? '#93C5FD' : '#3B82F6';
                    glow = isPlugged ? 'none' : '0 0 6px 2px rgba(59,130,246,0.45)';
                } else {
                    // Oil + default = green
                    color = isPlugged ? '#6EE7B7' : '#22C55E';
                    glow = isPlugged ? 'none' : '0 0 6px 2px rgba(34,197,94,0.5)';
                }
                // Non-producing active wells: dimmer, no glow
                if (!isPlugged && !producing && well.well_status === 'AC') {
                    glow = 'none';
                    return { color, glow, opacity: 0.55, producing: false };
                }
                return { color, glow, opacity: isPlugged ? 0.45 : 1, producing };
            }

            // Add filtered wells to map ‚Äî glowing circle dots
            wells.forEach(well => {
                if (well.api_number) {
                    window.nearbyWellsData[well.api_number] = well;
                }
                if (!well.latitude || !well.longitude) return;

                const isExtendedLateral = well.isExtendedLateral;
                const style = isExtendedLateral
                    ? { color: '#F59E0B', glow: '0 0 6px 2px rgba(245,158,11,0.5)', opacity: 1 }
                    : nearbyMarkerStyle(well);
                const dotSize = 12;

                const marker = L.marker([well.latitude, well.longitude], {
                    icon: L.divIcon({
                        className: 'nw-dot',
                        html: `<div style="width:${dotSize}px;height:${dotSize}px;border-radius:50%;background:${style.color};border:1px solid rgba(0,0,0,0.15);box-shadow:${style.glow};opacity:${style.opacity};"></div>`,
                        iconSize: [dotSize, dotSize],
                        iconAnchor: [dotSize / 2, dotSize / 2],
                        popupAnchor: [0, -dotSize / 2]
                    })
                });

                const wellBaseName = well.well_name || 'Unnamed Well';
                const wellNumber = well.well_number || '';
                const wellName = toTitleCase(wellNumber ? `${wellBaseName} ${wellNumber}` : wellBaseName);
                const operator = toTitleCase(well.operator || 'Unknown');
                const wellStatus = getStatusLabel(well.well_status);
                const formation = well.formation_name ? toTitleCase(well.formation_name) : '';
                const producing = style.producing;

                marker.wellData = well;

                const prodBadge = (well.well_status === 'AC' && !isExtendedLateral)
                    ? (producing
                        ? '<span style="display:inline-block;margin-left:6px;padding:1px 6px;border-radius:3px;font-size:10px;font-weight:600;background:#DCFCE7;color:#166534;">Producing</span>'
                        : '<span style="display:inline-block;margin-left:6px;padding:1px 6px;border-radius:3px;font-size:10px;font-weight:600;background:#FEF3C7;color:#92400E;">No Recent Prod</span>')
                    : '';

                const popupContent = `
                    <div class="popup-header">
                        <span class="popup-tag" style="background: ${isExtendedLateral ? '#FEF3C7' : '#E5E7EB'}; color: ${isExtendedLateral ? '#92400E' : '#374151'};">
                            ${isExtendedLateral ? 'Extended Lateral' : 'Nearby Well'}
                        </span>${prodBadge}
                    </div>
                    <div class="popup-well-name">${wellName}</div>
                    <div class="popup-details">
                        ${operator}<br>
                        ${(well.township||'').replace(/^(\d+)/, (_, n) => n.padStart(2, '0'))}-${(well.range||'').replace(/^(\d+)/, (_, n) => n.padStart(2, '0'))}-${(well.section||'').toString().padStart(2, '0')} ‚Ä¢ ${toTitleCase(well.county || 'Unknown')}<br>
                        Status: ${wellStatus}${formation ? ' \u2022 ' + formation : ''}
                        ${isExtendedLateral && well.lateral_length ? '<br>Lateral: ' + (well.lateral_length / 5280).toFixed(1) + ' miles' : ''}
                    </div>
                    <div class="popup-actions">
                        <button class="popup-btn popup-btn-secondary" data-api="${well.api_number}" onclick="expandNearbyWellCard(nearbyWellsData['${well.api_number}']); return false;">More \u2192</button>
                    </div>
                `;

                marker.bindPopup(popupContent, { maxWidth: 350, className: 'high-z-popup' });
                nearbyWellsLayer.addLayer(marker);

                // Collect lateral data (don't draw yet ‚Äî zoom-gated)
                if (well.bh_latitude && well.bh_longitude &&
                    (well.bh_latitude !== well.latitude || well.bh_longitude !== well.longitude)) {
                    const latDiff = Math.abs(well.bh_latitude - well.latitude);
                    const lngDiff = Math.abs(well.bh_longitude - well.longitude);
                    if ((latDiff + lngDiff) * 69 < 3) {
                        lateralData.push(well);
                    }
                }
            });

            // Ensure marker layer is on map
            if (!map.hasLayer(nearbyWellsLayer) && nearbyWellsLayer.getLayers().length > 0) {
                map.addLayer(nearbyWellsLayer);
            }

            // Build lateral lines in a separate layer (shown only at zoom >= 12)
            nearbyLateralsLayer.clearLayers();
            function buildNearbyLaterals() {
                nearbyLateralsLayer.clearLayers();
                lateralData.forEach(well => {
                    const wt = (well.well_type || '').toLowerCase();
                    const pathColor = wt.includes('gas') ? '#EF4444' : '#22C55E';
                    const line = L.polyline(
                        [[well.latitude, well.longitude], [well.bh_latitude, well.bh_longitude]],
                        { color: pathColor, weight: 3, opacity: 0.7 }
                    );
                    const lateralLength = well.lateral_length
                        ? Number(well.lateral_length).toLocaleString() + ' ft'
                        : '~' + Math.round(map.distance([well.latitude, well.longitude], [well.bh_latitude, well.bh_longitude]) * 3.28084).toLocaleString() + ' ft';
                    line.bindPopup(`
                        <div style="font-weight:600;margin-bottom:4px;">${toTitleCase(well.well_name || 'Unknown')}</div>
                        <div style="font-size:12px;color:#64748B;">${toTitleCase(well.operator || 'Unknown')}<br>Lateral: ${lateralLength}</div>
                    `, { maxWidth: 250, className: 'high-z-popup' });
                    nearbyLateralsLayer.addLayer(line);
                });
            }

            // Show laterals only when zoomed in enough to see them
            const LATERAL_MIN_ZOOM = 12;
            function updateLateralVisibility() {
                const zoom = map.getZoom();
                if (zoom >= LATERAL_MIN_ZOOM && lateralData.length > 0) {
                    if (nearbyLateralsLayer.getLayers().length === 0) {
                        buildNearbyLaterals();
                    }
                    if (!map.hasLayer(nearbyLateralsLayer)) {
                        map.addLayer(nearbyLateralsLayer);
                    }
                } else {
                    if (map.hasLayer(nearbyLateralsLayer)) {
                        map.removeLayer(nearbyLateralsLayer);
                    }
                }
            }

            // Remove previous zoom handler if any, then add new one
            if (window._nearbyZoomHandler) {
                map.off('zoomend', window._nearbyZoomHandler);
            }
            window._nearbyZoomHandler = updateLateralVisibility;
            map.on('zoomend', updateLateralVisibility);
            updateLateralVisibility(); // Apply immediately

            console.log(`${wells.length} nearby wells rendered, ${lateralData.length} laterals (zoom >= ${LATERAL_MIN_ZOOM})`);

            ensureLayerOrder();
            updateSearchIndex();
        }

        // Legend mode: 'wells' or 'filings'
        let legendMode = 'wells';
        let cachedFilingCounts = null;

        // Render operator legend inside map container (viewport-aware)
        function renderOperatorLegend() {
            if (!colorByOperator || !allNearbyWells || !allNearbyWells.length) {
                removeOperatorLegend();
                return;
            }

            // Filter to wells visible in current viewport
            const bounds = map.getBounds();
            const visibleWells = allNearbyWells.filter(w =>
                w.latitude && w.longitude && bounds.contains([w.latitude, w.longitude])
            );

            // Count wells per operator in viewport
            const wellCounts = {};
            visibleWells.forEach(w => {
                const op = (w.operator || 'Unknown').toUpperCase().trim();
                wellCounts[op] = (wellCounts[op] || 0) + 1;
            });

            // Reuse existing element or create new one
            let el = document.getElementById('operatorLegendPanel');
            if (!el) {
                el = document.createElement('div');
                el.className = 'operator-legend';
                el.id = 'operatorLegendPanel';
                document.querySelector('.map-container').appendChild(el);
                L.DomEvent.disableClickPropagation(el);
                L.DomEvent.disableScrollPropagation(el);
                el.addEventListener('click', function(e) {
                    const item = e.target.closest('.operator-legend-item[data-operator]');
                    if (item) {
                        e.stopPropagation();
                        openOperatorModal(item.getAttribute('data-operator'));
                    }
                    const toggle = e.target.closest('.legend-mode-toggle');
                    if (toggle) {
                        e.stopPropagation();
                        const newMode = toggle.getAttribute('data-mode');
                        if (newMode && newMode !== legendMode) {
                            toggleLegendMode();
                        }
                    }
                });
            }

            // Use filing counts if in filings mode and cached
            const useCounts = legendMode === 'filings' && cachedFilingCounts ? cachedFilingCounts : wellCounts;
            const sorted = Object.entries(useCounts).sort((a, b) => b[1] - a[1]);
            const topN = sorted.slice(0, 15);
            const otherCount = sorted.slice(15).reduce((sum, e) => sum + e[1], 0);
            const totalCount = legendMode === 'filings' && cachedFilingCounts
                ? Object.values(cachedFilingCounts).reduce((a, b) => a + b, 0)
                : visibleWells.length;

            const wellsActive = legendMode === 'wells' ? 'font-weight:700;color:#E2E8F0;' : 'font-weight:400;color:#64748B;cursor:pointer;';
            const filingsActive = legendMode === 'filings' ? 'font-weight:700;color:#E2E8F0;' : 'font-weight:400;color:#64748B;cursor:pointer;';

            let html = `<div class="operator-legend-title" style="display:flex;align-items:center;gap:6px;">
                <span>Operators</span>
                <span style="font-weight:400;color:#94A3B8;">(${totalCount})</span>
                <span style="margin-left:auto;font-size:10px;">
                    <span class="legend-mode-toggle" data-mode="wells" style="${wellsActive}">Wells</span>
                    <span style="color:#475569;"> | </span>
                    <span class="legend-mode-toggle" data-mode="filings" style="${filingsActive}">Filings</span>
                </span>
            </div>`;

            if (legendMode === 'filings' && !cachedFilingCounts) {
                html += '<div style="color:#94A3B8;font-size:12px;padding:8px 0;">Loading filings...</div>';
            } else {
                topN.forEach(([op, count]) => {
                    const color = operatorColorMap[op] || '#6B7280';
                    const display = toTitleCase(op);
                    html += `<div class="operator-legend-item" data-operator="${op.replace(/"/g, '&quot;')}">
                        <div class="operator-legend-dot" style="background:${color};"></div>
                        <div class="operator-legend-name">${display}</div>
                        <div class="operator-legend-count">${count}</div>
                    </div>`;
                });
                if (otherCount > 0) {
                    html += `<div class="operator-legend-item" style="cursor:default;">
                        <div class="operator-legend-dot" style="background:#6B7280;"></div>
                        <div class="operator-legend-name" style="color:#94A3B8;">Others</div>
                        <div class="operator-legend-count">${otherCount}</div>
                    </div>`;
                }
            }
            el.innerHTML = html;
        }

        function toggleLegendMode() {
            legendMode = legendMode === 'wells' ? 'filings' : 'wells';
            if (legendMode === 'filings') {
                cachedFilingCounts = null; // Invalidate on toggle
                renderOperatorLegend(); // Show loading state
                fetchAreaFilings();
            } else {
                renderOperatorLegend();
            }
        }

        async function fetchAreaFilings() {
            try {
                const bounds = map.getBounds();
                const resp = await fetch(`/api/map/area-filings?south=${bounds.getSouth()}&north=${bounds.getNorth()}&west=${bounds.getWest()}&east=${bounds.getEast()}`, {
                    credentials: 'include'
                });
                if (!resp.ok) throw new Error('Failed');
                const data = await resp.json();
                cachedFilingCounts = data.filings || {};
                renderOperatorLegend();
            } catch (err) {
                console.error('Failed to fetch area filings:', err);
                cachedFilingCounts = {};
                renderOperatorLegend();
            }
        }

        function removeOperatorLegend() {
            const el = document.getElementById('operatorLegendPanel');
            if (el) el.remove();
            legendMode = 'wells';
            cachedFilingCounts = null;
            // Remove map move handler
            if (window._operatorLegendHandler) {
                map.off('moveend zoomend', window._operatorLegendHandler);
                window._operatorLegendHandler = null;
            }
        }

        // Operator detail modal (scoped to visible wells when in operator color mode)
        function openOperatorModal(operatorName) {
            const overlay = document.getElementById('operatorModal');
            if (!overlay) return;

            const opKey = operatorName.toUpperCase().trim();
            let wells;
            let subtitle;
            if (colorByOperator) {
                // Scope to current viewport
                const bounds = map.getBounds();
                wells = (allNearbyWells || []).filter(w =>
                    (w.operator || 'Unknown').toUpperCase().trim() === opKey &&
                    w.latitude && w.longitude && bounds.contains([w.latitude, w.longitude])
                );
                subtitle = wells.length + ' wells in view';
            } else {
                wells = (allNearbyWells || []).filter(w =>
                    (w.operator || 'Unknown').toUpperCase().trim() === opKey
                );
                subtitle = wells.length + ' wells nearby';
            }

            const display = toTitleCase(operatorName);
            document.getElementById('operatorModalTitle').textContent = display;
            document.getElementById('operatorModalSubtitle').textContent = subtitle;

            // Contact info (from operators table via nearby-wells join)
            const sampleWell = wells.find(w => w.phone || w.contact_name) || {};
            const phone = sampleWell.phone || '';
            const contactName = sampleWell.contact_name ? toTitleCase(sampleWell.contact_name) : '';

            // Stats
            const producing = wells.filter(w => w.well_status === 'AC' && w.last_prod_month).length;
            const active = wells.filter(w => w.well_status === 'AC').length;
            const plugged = wells.filter(w => w.well_status === 'PA').length;
            const horizontal = wells.filter(w => w.bh_latitude && w.bh_longitude &&
                (Math.abs(w.bh_latitude - w.latitude) + Math.abs(w.bh_longitude - w.longitude)) * 69 > 0.3).length;

            // Formation breakdown
            const formCounts = {};
            wells.forEach(w => {
                const f = w.formation_name ? toTitleCase(w.formation_name) : 'Unknown';
                formCounts[f] = (formCounts[f] || 0) + 1;
            });
            const topFormations = Object.entries(formCounts).sort((a, b) => b[1] - a[1]).slice(0, 8);

            // County breakdown
            const countyCounts = {};
            wells.forEach(w => {
                const c = w.county ? toTitleCase(w.county) : 'Unknown';
                countyCounts[c] = (countyCounts[c] || 0) + 1;
            });
            const topCounties = Object.entries(countyCounts).sort((a, b) => b[1] - a[1]).slice(0, 5);

            let body = '';

            // Contact info
            if (phone || contactName) {
                body += `<div class="op-section" style="margin-bottom:12px;">
                    <div style="display:flex;align-items:center;gap:12px;padding:10px 14px;background:#F0F9FF;border:1px solid #BAE6FD;border-radius:8px;">
                        <div style="font-size:18px;">&#128222;</div>
                        <div style="flex:1;">
                            ${contactName ? `<div style="font-weight:600;color:#1E293B;font-size:14px;">${contactName}</div>` : ''}
                            ${phone ? `<a href="tel:${phone.replace(/\\D/g, '')}" style="color:#1E40AF;font-size:13px;text-decoration:none;">${phone}</a>` : ''}
                        </div>
                    </div>
                </div>`;
            }

            body += `<div class="op-stats">
                <div class="op-stat"><div class="op-stat-value">${active}</div><div class="op-stat-label">Active</div></div>
                <div class="op-stat"><div class="op-stat-value">${producing}</div><div class="op-stat-label">Producing</div></div>
                <div class="op-stat"><div class="op-stat-value">${plugged}</div><div class="op-stat-label">Plugged</div></div>
                <div class="op-stat"><div class="op-stat-value">${horizontal}</div><div class="op-stat-label">Horizontal</div></div>
            </div>`;

            // Formations section
            if (topFormations.length > 0) {
                body += `<div class="op-section"><div class="op-section-title">Formations</div><div style="display:flex;gap:6px;flex-wrap:wrap;">`;
                topFormations.forEach(([f, c]) => {
                    body += `<span style="display:inline-block;padding:3px 10px;border-radius:12px;font-size:12px;background:#EFF6FF;color:#1E40AF;border:1px solid #BFDBFE;">${f} <span style="font-weight:600;">${c}</span></span>`;
                });
                body += `</div></div>`;
            }

            // Counties section
            if (topCounties.length > 0) {
                body += `<div class="op-section"><div class="op-section-title">Counties</div><div style="display:flex;gap:6px;flex-wrap:wrap;">`;
                topCounties.forEach(([c, count]) => {
                    body += `<span style="display:inline-block;padding:3px 10px;border-radius:12px;font-size:12px;background:#F1F5F9;color:#334155;border:1px solid #CBD5E1;">${c} <span style="font-weight:600;">${count}</span></span>`;
                });
                body += `</div></div>`;
            }

            // Wells table (top 50 by status then name)
            const sortedWells = [...wells].sort((a, b) => {
                if (a.well_status === 'AC' && b.well_status !== 'AC') return -1;
                if (a.well_status !== 'AC' && b.well_status === 'AC') return 1;
                return (a.well_name || '').localeCompare(b.well_name || '');
            });
            const showWells = sortedWells.slice(0, 50);

            body += `<div class="op-section"><div class="op-section-title">Wells${wells.length > 50 ? ' (showing top 50)' : ''}</div>
                <table class="op-wells-table">
                    <thead><tr><th>Well Name</th><th>Status</th><th>Formation</th><th>TRS</th></tr></thead>
                    <tbody>`;
            showWells.forEach(w => {
                const name = toTitleCase(w.well_name || 'Unknown');
                const num = w.well_number || '';
                const fullName = num ? `${name} ${num}` : name;
                const status = getStatusLabel(w.well_status);
                const formation = w.formation_name ? toTitleCase(w.formation_name) : '';
                const trs = `${(w.township||'').replace(/^(\d+)/, (_, n) => n.padStart(2, '0'))}-${(w.range||'').replace(/^(\d+)/, (_, n) => n.padStart(2, '0'))}-${(w.section||'').toString().padStart(2, '0')}`;
                body += `<tr>
                    <td class="clickable" onclick="if(nearbyWellsData['${w.api_number}']){expandNearbyWellCard(nearbyWellsData['${w.api_number}']);}">${fullName}</td>
                    <td>${status}</td>
                    <td>${formation}</td>
                    <td style="white-space:nowrap;">${trs}</td>
                </tr>`;
            });
            body += `</tbody></table></div>`;

            // OCC Activity section (loaded async)
            body += `<div class="op-section" id="opActivitySection">
                <div class="op-section-title">OCC Activity</div>
                <div id="opActivityContent" style="color:#94A3B8;font-size:13px;">Loading filings...</div>
            </div>`;

            document.getElementById('operatorModalBody').innerHTML = body;

            // Fetch OCC activity async
            loadOperatorActivity(operatorName);
            overlay.classList.add('active');
        }

        function closeOperatorModal() {
            const overlay = document.getElementById('operatorModal');
            if (overlay) overlay.classList.remove('active');
        }

        // Relief type display labels
        const RELIEF_LABELS = {
            'POOLING': 'Pooling',
            'INCREASED_DENSITY': 'Increased Density',
            'SPACING': 'Spacing',
            'HORIZONTAL_WELL': 'Horizontal Well',
            'LOCATION_EXCEPTION': 'Location Exception',
            'OPERATOR_CHANGE': 'Operator Change',
            'WELL_TRANSFER': 'Well Transfer',
            'ORDER_MODIFICATION': 'Order Modification',
            'MULTI_UNIT_HORIZONTAL': 'Multi-Unit Horizontal',
            'VACUUM': 'Vacuum',
            'OTHER': 'Other'
        };

        const RELIEF_COLORS = {
            'POOLING': '#F59E0B',
            'INCREASED_DENSITY': '#8B5CF6',
            'SPACING': '#3B82F6',
            'HORIZONTAL_WELL': '#22C55E',
            'LOCATION_EXCEPTION': '#EC4899',
            'OPERATOR_CHANGE': '#6B7280',
            'WELL_TRANSFER': '#6B7280',
            'ORDER_MODIFICATION': '#6B7280'
        };

        async function loadOperatorActivity(operatorName) {
            const el = document.getElementById('opActivityContent');
            if (!el) return;

            try {
                const bounds = map.getBounds();
                const boundsParams = `&south=${bounds.getSouth()}&north=${bounds.getNorth()}&west=${bounds.getWest()}&east=${bounds.getEast()}`;
                const resp = await fetch(`/api/map/operator-activity?operator=${encodeURIComponent(operatorName)}${boundsParams}`, {
                    credentials: 'include'
                });
                if (!resp.ok) {
                    const errBody = await resp.text();
                    console.error('Operator activity API error:', resp.status, errBody);
                    throw new Error('Failed to load');
                }
                const data = await resp.json();

                if (data.totalFilings === 0 && data.poolingCount === 0) {
                    el.innerHTML = '<div style="color:#94A3B8;font-style:italic;">No OCC filings found for this operator</div>';
                    return;
                }

                let html = '';

                // Type summary tags
                if (data.typeSummary && data.typeSummary.length > 0) {
                    html += '<div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:12px;">';
                    data.typeSummary.forEach(t => {
                        const label = RELIEF_LABELS[t.type] || t.type;
                        const color = RELIEF_COLORS[t.type] || '#6B7280';
                        html += `<span style="display:inline-flex;align-items:center;gap:4px;padding:4px 10px;border-radius:12px;font-size:12px;background:${color}18;color:${color};border:1px solid ${color}40;font-weight:500;">
                            ${label} <span style="font-weight:700;">${t.count}</span>
                        </span>`;
                    });
                    html += '</div>';
                }

                // Recent filings table
                if (data.recentFilings && data.recentFilings.length > 0) {
                    html += `<table class="op-wells-table" style="margin-top:4px;">
                        <thead><tr><th>Type</th><th>Case</th><th>Location</th><th>Date</th><th>Status</th></tr></thead>
                        <tbody>`;
                    data.recentFilings.forEach(f => {
                        const label = RELIEF_LABELS[f.reliefType] || f.reliefType;
                        const color = RELIEF_COLORS[f.reliefType] || '#6B7280';
                        const trs = f.township && f.range && f.section
                            ? `${(f.township||'').replace(/^(\\d+)/, (_, n) => n.padStart(2, '0'))}-${(f.range||'').replace(/^(\\d+)/, (_, n) => n.padStart(2, '0'))}-${String(f.section).padStart(2, '0')}`
                            : '';
                        const date = f.docketDate || f.hearingDate || '';
                        const shortDate = date ? date.substring(0, 10) : '';
                        const statusColor = f.status === 'SCHEDULED' ? '#F59E0B' : f.status === 'HEARD' ? '#22C55E' : '#94A3B8';
                        html += `<tr>
                            <td><span style="color:${color};font-weight:500;">${label}</span></td>
                            <td style="font-size:12px;">${f.caseNumber || ''}</td>
                            <td style="white-space:nowrap;">${trs}</td>
                            <td style="white-space:nowrap;font-size:12px;">${shortDate}</td>
                            <td><span style="color:${statusColor};font-size:12px;">${f.status || ''}</span></td>
                        </tr>`;
                    });
                    html += '</tbody></table>';
                    if (data.totalFilings > 20) {
                        html += `<div style="text-align:center;font-size:12px;color:#94A3B8;margin-top:6px;">Showing 20 of ${data.totalFilings} filings</div>`;
                    }
                }

                // Pooling orders summary
                if (data.poolingOrders && data.poolingOrders.length > 0) {
                    html += `<div style="margin-top:12px;padding-top:12px;border-top:1px solid #E5E7EB;">
                        <div style="font-size:11px;font-weight:600;color:#64748B;text-transform:uppercase;letter-spacing:0.3px;margin-bottom:8px;">Pooling Orders (${data.poolingCount})</div>
                        <table class="op-wells-table">
                            <thead><tr><th>Well Name</th><th>Location</th><th>Date</th><th>Max Bonus</th></tr></thead>
                            <tbody>`;
                    data.poolingOrders.slice(0, 15).forEach(po => {
                        const trs = po.township && po.range && po.section
                            ? `${(po.township||'').replace(/^(\\d+)/, (_, n) => n.padStart(2, '0'))}-${(po.range||'').replace(/^(\\d+)/, (_, n) => n.padStart(2, '0'))}-${String(po.section).padStart(2, '0')}`
                            : '';
                        const bonus = po.maxBonus ? `$${Math.round(po.maxBonus).toLocaleString()}` : '';
                        html += `<tr>
                            <td>${po.wellName ? toTitleCase(po.wellName) : po.caseNumber || ''}</td>
                            <td style="white-space:nowrap;">${trs}</td>
                            <td style="white-space:nowrap;font-size:12px;">${po.orderDate || ''}</td>
                            <td style="color:#059669;font-weight:600;">${bonus}</td>
                        </tr>`;
                    });
                    html += '</tbody></table></div>';
                }

                el.innerHTML = html;

            } catch (err) {
                console.error('Failed to load operator activity:', err);
                el.innerHTML = '<div style="color:#94A3B8;font-style:italic;">Could not load OCC activity</div>';
            }
        }

