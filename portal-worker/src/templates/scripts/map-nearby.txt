        // Toggle nearby wells from D1 database
        function toggleNearbyWells() {
            console.log('toggleNearbyWells called');
            const select = document.getElementById('nearby-wells-select');
            const value = select.value;
            const countDiv = document.getElementById('nearbyWellsCount');
            const separatorDiv = document.getElementById('nearbyWellsSeparator');

            console.log('Nearby wells select value:', value);
            console.log('User properties count:', userProperties.length);

            // Update active state based on selection
            if (value !== 'off') {
                select.classList.add('active');
                if (countDiv) countDiv.style.display = 'flex';
                if (separatorDiv) separatorDiv.style.display = 'block';
                console.log('Calling loadNearbyWells...');
                loadNearbyWells();
            } else {
                select.classList.remove('active');
                if (nearbyWellsLayer && map.hasLayer(nearbyWellsLayer)) {
                    map.removeLayer(nearbyWellsLayer);
                }
                if (nearbyLateralsLayer && map.hasLayer(nearbyLateralsLayer)) {
                    map.removeLayer(nearbyLateralsLayer);
                }
                if (countDiv) countDiv.style.display = 'none';
                if (separatorDiv) separatorDiv.style.display = 'none';
                const filterPanel = document.getElementById('wellsFilterPanel');
                if (filterPanel) filterPanel.style.display = 'none';
                const wellCount = document.getElementById('nearbyWellCount');
                if (wellCount) wellCount.textContent = '0';
                // Remove nearby wells from search index
                updateSearchIndex();
            }
        }


        // Helper function to generate cache key
        function getWellsCacheKey(status) {
            // Include a hash of property IDs to invalidate when properties change
            const propertyIds = userProperties.map(p => p.id).sort().join(',');
            const propertyHash = btoa(propertyIds).substring(0, 8); // Short hash
            // Add version number to invalidate old caches
            const CACHE_VERSION = 'v9'; // Fixed nearby-wells to query one TRS at a time
            return `mw_nearby_wells_${status}_${propertyHash}_${CACHE_VERSION}`;
        }

        // Helper function to clear all nearby wells caches
        function clearNearbyWellsCache() {
            const keys = Object.keys(localStorage).filter(k => k.includes('mw_nearby_wells'));
            keys.forEach(k => localStorage.removeItem(k));
            console.log(`Cleared ${keys.length} nearby wells cache entries`);
        }

        // Make it available globally for debugging
        window.clearNearbyWellsCache = clearNearbyWellsCache;

        // Helper function to show loading overlay on map
        function showMapLoadingOverlay(message = 'Loading...') {
            // Show a lightweight loading indicator for nearby wells select
            const select = document.getElementById('nearby-wells-select');
            if (select) {
                select.classList.add('loading');
                select.classList.add('active'); // Keep orange styling
                // Store original option text and change to Loading...
                const selectedOption = select.options[select.selectedIndex];
                select.setAttribute('data-original-text', selectedOption.text);
                selectedOption.text = 'Loading...';
            }
        }

        function hideMapLoadingOverlay() {
            // Remove loading state from nearby wells select
            const select = document.getElementById('nearby-wells-select');
            if (select) {
                select.classList.remove('loading');
                // Restore original option text
                const originalText = select.getAttribute('data-original-text');
                if (originalText) {
                    select.options[select.selectedIndex].text = originalText;
                    select.removeAttribute('data-original-text');
                }
            }
        }

        // Load wells from D1 database based on user properties (3x3 sections)
        async function loadNearbyWells() {
            console.log('loadNearbyWells started');
            console.log('userProperties:', userProperties);

            // Ensure we have user properties
            if (!userProperties || userProperties.length === 0) {
                console.error('No user properties loaded yet');
                updateStatus('No properties found - please refresh the page');
                return;
            }

            try {
                // Get status filter from the dropdown
                const statusFilter = document.getElementById('nearby-wells-select').value;
                console.log('Status filter value:', statusFilter);
                if (statusFilter === 'off') {
                    console.log('Nearby wells is off, not loading');
                    return;
                }
                const statusText = statusFilter === 'AC' ? 'active' : 'all';
                const cacheKey = getWellsCacheKey(statusFilter);

                // Check cache first
                const cachedData = localStorage.getItem(cacheKey);
                if (cachedData) {
                    try {
                        const cached = JSON.parse(cachedData);
                        const cacheAge = Date.now() - cached.timestamp;
                        const MAX_CACHE_AGE = 24 * 60 * 60 * 1000; // 24 hours

                        // Don't use cache if it's empty or too old
                        if (cacheAge < MAX_CACHE_AGE && cached.wells && cached.wells.length > 0) {
                            console.log(`Using cached ${statusText} wells data (${Math.round(cacheAge / 1000 / 60)} minutes old)`);
                            allNearbyWells = cached.wells;
                            const filteredWells = filterWellsData(cached.wells);
                            displayFilteredWells(filteredWells);
                            updateStatus(`Displayed ${cached.wells.length} ${statusText} wells (from cache)`);
                            return;
                        } else if (cached.wells && cached.wells.length === 0) {
                            console.log('Cache contains 0 wells, invalidating and fetching fresh data');
                            localStorage.removeItem(cacheKey);
                        }
                    } catch (e) {
                        console.error('Failed to parse cached data:', e);
                        localStorage.removeItem(cacheKey);
                    }
                }

                // Show loading overlay
                showMapLoadingOverlay(`Loading ${statusText} wells...`);
                updateStatus('Loading nearby wells...');

                // Get TRS sections for all user properties ‚Äî 3x3 core + 5x5 extended in one pass
                const propertySections = await getPropertyNearbySections();

                if (propertySections.length === 0) {
                    hideMapLoadingOverlay();
                    updateStatus('No properties found');
                    return;
                }

                // Build combined TRS set: 3x3 core + 5x5 outer ring (for long laterals)
                const coreSections = new Set(propertySections);
                const extendedOnlySections = new Set();

                for (const property of userProperties) {
                    const fields = property.fields || property;
                    const section = parseInt(fields.SEC || fields.Section);
                    let township = (fields.TWN || fields.Township || '').replace(/\s+/g, '').toUpperCase();
                    let range = (fields.RNG || fields.Range || '').replace(/\s+/g, '').toUpperCase();
                    township = township.replace(/^T/, '');
                    range = range.replace(/^R/, '');
                    const meridian = fields.MERIDIAN || 'IM';

                    if (section && township && range) {
                        const extendedNearbySections = get5x5Sections(section, township, range, meridian);
                        extendedNearbySections.forEach(trs => {
                            if (!coreSections.has(trs)) {
                                extendedOnlySections.add(trs);
                            }
                        });
                    }
                }

                // Single API call with all sections (core + extended)
                const allSections = [...propertySections, ...extendedOnlySections];
                console.log(`Loading ${statusText} wells: ${propertySections.length} core + ${extendedOnlySections.size} extended = ${allSections.length} sections`);

                const response = await fetch('/api/nearby-wells', {
                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        trs: allSections,
                        status: statusFilter.toLowerCase(),
                        limit: 25000
                    })
                });

                if (!response.ok) {
                    hideMapLoadingOverlay();
                    console.error('Failed to load wells:', response.status);
                    updateStatus('Failed to load wells');
                    return;
                }

                const result = await response.json();
                const allWells = result.data?.wells || [];
                console.log(`Received ${allWells.length} wells in ${result.data?.query?.executionTime}ms`);

                // Tag wells from extended-only sections as extended laterals
                // (only keep them if they have long laterals > 1 mile with BH coords)
                const filteredAllWells = allWells.filter(well => {
                    const trs = `${well.section}-${well.township}-${well.range}-${well.meridian}`;
                    if (extendedOnlySections.has(trs)) {
                        if (well.lateral_length && well.lateral_length > 5280 &&
                            well.bh_latitude && well.bh_longitude) {
                            well.isExtendedLateral = true;
                            return true;
                        }
                        return false; // Drop non-lateral wells from extended ring
                    }
                    return true; // Keep all core wells
                });

                // Remove duplicates
                const uniqueWells = Array.from(
                    new Map(filteredAllWells.map(w => [w.api_number, w])).values()
                );
                console.log(`${uniqueWells.length} unique wells after filtering`);

                // Cache the results
                try {
                    localStorage.setItem(cacheKey, JSON.stringify({
                        wells: uniqueWells,
                        timestamp: Date.now()
                    }));
                } catch (e) {
                    // Clear old cache if storage is full
                    try {
                        Object.keys(localStorage).filter(k => k.startsWith('mw_nearby_wells_')).forEach(k => {
                            localStorage.removeItem(k);
                        });
                    } catch (clearError) { /* ignore */ }
                }

                // Store wells for filtering
                allNearbyWells = uniqueWells;

                // Display wells (respecting any active filters)
                const filteredWells = filterWellsData(uniqueWells);
                console.log(`After filtering: ${filteredWells.length} wells to display`);
                displayFilteredWells(filteredWells);

                // Hide loading indicator after wells are displayed
                hideMapLoadingOverlay();

                // Update status
                if (filteredWells.length < uniqueWells.length) {
                    const filterCount = Object.values(wellsFilterState).filter(v => v).length;
                    updateStatus(`Loaded ${uniqueWells.length} wells, showing ${filteredWells.length} (${filterCount} filters active)`);
                } else {
                    updateStatus(`Loaded ${uniqueWells.length} wells from D1 database`);
                }

                // Clear status after delay
                setTimeout(() => updateStatus('Map ready'), 3000);

            } catch (error) {
                console.error('Error loading nearby wells:', error);
                hideMapLoadingOverlay();
                updateStatus('Failed to load wells');
                setTimeout(() => updateStatus('Map ready'), 3000);
            }
        }

        // Get 3x3 sections around user properties
        async function getPropertyNearbySections() {
            const sectionsSet = new Set();

            // For each property, get its section and 3x3 neighbors
            for (const property of userProperties) {
                const fields = property.fields || property;

                // Get property TRS
                const section = parseInt(fields.SEC || fields.Section);
                let township = (fields.TWN || fields.Township || '').replace(/\s+/g, '').toUpperCase();
                let range = (fields.RNG || fields.Range || '').replace(/\s+/g, '').toUpperCase();

                // Remove S/T/R prefixes if present
                township = township.replace(/^T/, '');
                range = range.replace(/^R/, '');

                // Get meridian - default to IM unless property has CM
                const meridian = fields.MERIDIAN || 'IM';

                // Log raw values for debugging
                console.log(`Property ${property.id}: Raw TWN="${fields.TWN || fields.Township}", RNG="${fields.RNG || fields.Range}", MERIDIAN="${meridian}"`);
                console.log(`Property ${property.id}: Parsed section=${section}, township=${township}, range=${range}, meridian=${meridian}`);

                if (!section || !township || !range) {
                    console.warn(`Property ${property.id} skipped - missing TRS data`);
                    continue;
                }

                // Get 3x3 sections around this property with proper meridian
                const nearbySections = get3x3Sections(section, township, range, meridian);
                nearbySections.forEach(trs => sectionsSet.add(trs));
            }

            return Array.from(sectionsSet);
        }

        // Get 3x3 grid of sections centered on given section
        function get3x3Sections(centerSection, township, range, meridian = 'IM') {
            const sections = [];

            // Standard 6x6 section layout
            const sectionGrid = [
                [6,  5,  4,  3,  2,  1],
                [7,  8,  9,  10, 11, 12],
                [18, 17, 16, 15, 14, 13],
                [19, 20, 21, 22, 23, 24],
                [30, 29, 28, 27, 26, 25],
                [31, 32, 33, 34, 35, 36]
            ];

            // Find center section position
            let centerRow = -1, centerCol = -1;
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 6; col++) {
                    if (sectionGrid[row][col] === centerSection) {
                        centerRow = row;
                        centerCol = col;
                        break;
                    }
                }
            }

            if (centerRow === -1) return [`${centerSection}-${township}-${range}-${meridian}`];

            // Get 3x3 grid (1 section in each direction)
            for (let row = Math.max(0, centerRow - 1); row <= Math.min(5, centerRow + 1); row++) {
                for (let col = Math.max(0, centerCol - 1); col <= Math.min(5, centerCol + 1); col++) {
                    const section = sectionGrid[row][col];
                    sections.push(`${section}-${township}-${range}-${meridian}`);
                }
            }

            return sections;
        }

        // Get 5x5 grid of sections centered on given section (for extended lateral search)
        function get5x5Sections(centerSection, township, range, meridian = 'IM') {
            const sections = [];

            // Standard 6x6 section layout
            const sectionGrid = [
                [6,  5,  4,  3,  2,  1],
                [7,  8,  9,  10, 11, 12],
                [18, 17, 16, 15, 14, 13],
                [19, 20, 21, 22, 23, 24],
                [30, 29, 28, 27, 26, 25],
                [31, 32, 33, 34, 35, 36]
            ];

            // Find center section position
            let centerRow = -1, centerCol = -1;
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 6; col++) {
                    if (sectionGrid[row][col] === centerSection) {
                        centerRow = row;
                        centerCol = col;
                        break;
                    }
                }
            }

            if (centerRow === -1) return [`${centerSection}-${township}-${range}-${meridian}`];

            // Get 5x5 grid (2 sections in each direction)
            for (let row = Math.max(0, centerRow - 2); row <= Math.min(5, centerRow + 2); row++) {
                for (let col = Math.max(0, centerCol - 2); col <= Math.min(5, centerCol + 2); col++) {
                    const section = sectionGrid[row][col];
                    sections.push(`${section}-${township}-${range}-${meridian}`);
                }
            }

            return sections;
        }

        // Parse PLSS ID to extract township/range
        function parsePlssId(plssId) {
            if (!plssId) return null;

            // Format: "OK170230N0080W0"
            const match = plssId.match(/OK\d{2}(\d{3})([NS])(\d{3})([EW])/);
            if (match) {
                const twpNum = parseInt(match[1], 10);
                const twpDir = match[2];
                const rngNum = parseInt(match[3], 10);
                const rngDir = match[4];

                return {
                    township: `${twpNum}${twpDir}`,
                    range: `${rngNum}${rngDir}`
                };
            }

            return null;
        }

        // No automatic refresh on map move - wells are loaded based on properties only

        // Wells filter state
        let wellsFilterState = {
            status: '',
            type: '',
            operator: '',
            county: ''
        };

        // All wells data (before filtering)
        let allNearbyWells = [];

        // Filter wells data based on current filter state
        function filterWellsData(wells) {
            return wells.filter(well => {
                // Status filter
                if (wellsFilterState.status && well.well_status !== wellsFilterState.status) {
                    return false;
                }

                // Type filter
                if (wellsFilterState.type && well.well_type !== wellsFilterState.type) {
                    return false;
                }

                // Operator filter (partial match)
                if (wellsFilterState.operator && !well.operator?.toLowerCase().includes(wellsFilterState.operator)) {
                    return false;
                }

                // County filter (partial match)
                if (wellsFilterState.county && !well.county?.toLowerCase().includes(wellsFilterState.county)) {
                    return false;
                }

                return true;
            });
        }

        // Toggle wells filter panel
        function toggleWellsFilter() {
            const panel = document.getElementById('wellsFilterPanel');
            const button = document.getElementById('filterToggleBtn');

            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                button.classList.add('active');
            } else {
                panel.style.display = 'none';
                button.classList.remove('active');
            }
        }

        // Apply wells filter
        function applyWellsFilter() {
            // Get filter values
            wellsFilterState.status = document.getElementById('filterWellStatus').value;
            wellsFilterState.type = document.getElementById('filterWellType').value;
            wellsFilterState.operator = document.getElementById('filterOperator').value.toLowerCase();
            wellsFilterState.county = document.getElementById('filterCounty').value.toLowerCase();

            // Filter wells
            const filteredWells = allNearbyWells.filter(well => {
                // Status filter
                if (wellsFilterState.status && well.well_status !== wellsFilterState.status) {
                    return false;
                }

                // Type filter
                if (wellsFilterState.type && well.well_type !== wellsFilterState.type) {
                    return false;
                }

                // Operator filter (partial match)
                if (wellsFilterState.operator && !well.operator?.toLowerCase().includes(wellsFilterState.operator)) {
                    return false;
                }

                // County filter (partial match)
                if (wellsFilterState.county && !well.county?.toLowerCase().includes(wellsFilterState.county)) {
                    return false;
                }

                return true;
            });

            // Update map
            displayFilteredWells(filteredWells);

            // Update status
            const filterCount = Object.values(wellsFilterState).filter(v => v).length;
            if (filterCount > 0) {
                updateStatus(`Showing ${filteredWells.length} of ${allNearbyWells.length} wells (${filterCount} filters active)`);
                document.getElementById('filterToggleBtn').innerHTML = '<span>üîç Filter Wells (' + filterCount + ')</span>';
            } else {
                updateStatus(`Showing all ${allNearbyWells.length} wells`);
                document.getElementById('filterToggleBtn').innerHTML = '<span>üîç Filter Wells</span>';
            }

            // Close panel
            toggleWellsFilter();
        }

        // Clear wells filter
        function clearWellsFilter() {
            // Reset form
            document.getElementById('filterWellStatus').value = '';
            document.getElementById('filterWellType').value = '';
            document.getElementById('filterOperator').value = '';
            document.getElementById('filterCounty').value = '';

            // Reset state
            wellsFilterState = {
                status: '',
                type: '',
                operator: '',
                county: ''
            };

            // Show all wells
            displayFilteredWells(allNearbyWells);
            updateStatus(`Showing all ${allNearbyWells.length} wells`);
            document.getElementById('filterToggleBtn').innerHTML = '<span>üîç Filter Wells</span>';

            // Close panel
            toggleWellsFilter();
        }

        // Display filtered wells on map
        function displayFilteredWells(wells) {
            // Initialize cluster group if not already done
            if (!nearbyWellsLayer) {
                nearbyWellsLayer = L.markerClusterGroup({
                    disableClusteringAtZoom: 13,  // Keep clustering until township-level zoom
                    maxClusterRadius: 80,
                    spiderfyOnMaxZoom: true,
                    showCoverageOnHover: false,
                    zoomToBoundsOnClick: true,
                    chunkedLoading: true,          // Non-blocking ‚Äî prevents UI freeze with thousands of markers
                    chunkInterval: 100,
                    chunkDelay: 10,
                    iconCreateFunction: function(cluster) {
                        const count = cluster.getChildCount();
                        let className = 'marker-cluster-small';

                        if (count > 100) {
                            className = 'marker-cluster-large';
                        } else if (count > 25) {
                            className = 'marker-cluster-medium';
                        }

                        return new L.DivIcon({
                            html: '<div><span>' + count + '</span></div>',
                            className: 'marker-cluster ' + className,
                            iconSize: new L.Point(40, 40)
                        });
                    }
                });
            }

            // Clear existing wells
            nearbyWellsLayer.clearLayers();

            // Build set of tracked well API numbers for fast lookup
            const trackedAPIs = new Set();
            if (trackedWells && trackedWells.length > 0) {
                trackedWells.forEach(well => {
                    if (well.apiNumber) {
                        trackedAPIs.add(well.apiNumber);
                    }
                });
                console.log(`Filtering out ${trackedAPIs.size} tracked wells from nearby wells display`);
            }

            // Filter out tracked wells
            const untracked = wells.filter(well => {
                return !trackedAPIs.has(well.api_number);
            });

            console.log(`Displaying ${untracked.length} untracked wells (filtered ${wells.length - untracked.length} tracked wells)`);
            wells = untracked;

            // Update nearby wells count
            document.getElementById('nearbyWellCount').textContent = wells.length;

            // Store wells data globally for popup access
            window.nearbyWellsData = {};

            // Collect lateral data separately ‚Äî drawn only when zoomed in
            const lateralData = [];

            // Determine marker color + glow based on well type and status
            function nearbyMarkerStyle(well) {
                const isPlugged = well.well_status === 'PA';
                const wt = (well.well_type || '').toLowerCase();
                let color, glow;
                if (wt.includes('gas')) {
                    color = isPlugged ? '#F87171' : '#EF4444';
                    glow = isPlugged ? 'none' : '0 0 6px 2px rgba(239,68,68,0.5)';
                } else if (wt.includes('injection') || wt.includes('swd')) {
                    color = isPlugged ? '#93C5FD' : '#3B82F6';
                    glow = isPlugged ? 'none' : '0 0 6px 2px rgba(59,130,246,0.45)';
                } else {
                    // Oil + default = green (matches cover image)
                    color = isPlugged ? '#6EE7B7' : '#22C55E';
                    glow = isPlugged ? 'none' : '0 0 6px 2px rgba(34,197,94,0.5)';
                }
                return { color, glow, opacity: isPlugged ? 0.45 : 1 };
            }

            // Add filtered wells to map ‚Äî glowing circle dots
            wells.forEach(well => {
                if (well.api_number) {
                    window.nearbyWellsData[well.api_number] = well;
                }
                if (!well.latitude || !well.longitude) return;

                const isExtendedLateral = well.isExtendedLateral;
                const style = isExtendedLateral
                    ? { color: '#F59E0B', glow: '0 0 6px 2px rgba(245,158,11,0.5)', opacity: 1 }
                    : nearbyMarkerStyle(well);
                const dotSize = 9;

                const marker = L.marker([well.latitude, well.longitude], {
                    icon: L.divIcon({
                        className: 'nw-dot',
                        html: `<div style="width:${dotSize}px;height:${dotSize}px;border-radius:50%;background:${style.color};border:1.5px solid rgba(255,255,255,0.9);box-shadow:${style.glow};opacity:${style.opacity};"></div>`,
                        iconSize: [dotSize, dotSize],
                        iconAnchor: [dotSize / 2, dotSize / 2],
                        popupAnchor: [0, -dotSize / 2]
                    })
                });

                const wellBaseName = well.well_name || 'Unnamed Well';
                const wellNumber = well.well_number || '';
                const wellName = toTitleCase(wellNumber ? `${wellBaseName} ${wellNumber}` : wellBaseName);
                const operator = toTitleCase(well.operator || 'Unknown');
                const wellStatus = getStatusLabel(well.well_status);
                const formation = well.formation_name ? toTitleCase(well.formation_name) : '';

                marker.wellData = well;

                const popupContent = `
                    <div class="popup-header">
                        <span class="popup-tag" style="background: ${isExtendedLateral ? '#FEF3C7' : '#E5E7EB'}; color: ${isExtendedLateral ? '#92400E' : '#374151'};">
                            ${isExtendedLateral ? 'Extended Lateral' : 'Nearby Well'}
                        </span>
                    </div>
                    <div class="popup-well-name">${wellName}</div>
                    <div class="popup-details">
                        ${operator}<br>
                        ${(well.township||'').replace(/^(\d+)/, (_, n) => n.padStart(2, '0'))}-${(well.range||'').replace(/^(\d+)/, (_, n) => n.padStart(2, '0'))}-${(well.section||'').toString().padStart(2, '0')} ‚Ä¢ ${toTitleCase(well.county || 'Unknown')}<br>
                        Status: ${wellStatus}${formation ? ' \u2022 ' + formation : ''}
                        ${isExtendedLateral && well.lateral_length ? '<br>Lateral: ' + (well.lateral_length / 5280).toFixed(1) + ' miles' : ''}
                    </div>
                    <div class="popup-actions">
                        <button class="popup-btn popup-btn-secondary" data-api="${well.api_number}" onclick="expandNearbyWellCard(nearbyWellsData['${well.api_number}']); return false;">More \u2192</button>
                    </div>
                `;

                marker.bindPopup(popupContent, { maxWidth: 350, className: 'high-z-popup' });
                nearbyWellsLayer.addLayer(marker);

                // Collect lateral data (don't draw yet ‚Äî zoom-gated)
                if (well.bh_latitude && well.bh_longitude &&
                    (well.bh_latitude !== well.latitude || well.bh_longitude !== well.longitude)) {
                    const latDiff = Math.abs(well.bh_latitude - well.latitude);
                    const lngDiff = Math.abs(well.bh_longitude - well.longitude);
                    if ((latDiff + lngDiff) * 69 < 3) {
                        lateralData.push(well);
                    }
                }
            });

            // Ensure marker layer is on map
            if (!map.hasLayer(nearbyWellsLayer) && nearbyWellsLayer.getLayers().length > 0) {
                map.addLayer(nearbyWellsLayer);
            }

            // Build lateral lines in a separate layer (shown only at zoom >= 12)
            nearbyLateralsLayer.clearLayers();
            function buildNearbyLaterals() {
                nearbyLateralsLayer.clearLayers();
                lateralData.forEach(well => {
                    const wt = (well.well_type || '').toLowerCase();
                    const pathColor = wt.includes('gas') ? '#EF4444' : '#22C55E';
                    const line = L.polyline(
                        [[well.latitude, well.longitude], [well.bh_latitude, well.bh_longitude]],
                        { color: pathColor, weight: 3, opacity: 0.7 }
                    );
                    const lateralLength = well.lateral_length
                        ? Number(well.lateral_length).toLocaleString() + ' ft'
                        : '~' + Math.round(map.distance([well.latitude, well.longitude], [well.bh_latitude, well.bh_longitude]) * 3.28084).toLocaleString() + ' ft';
                    line.bindPopup(`
                        <div style="font-weight:600;margin-bottom:4px;">${toTitleCase(well.well_name || 'Unknown')}</div>
                        <div style="font-size:12px;color:#64748B;">${toTitleCase(well.operator || 'Unknown')}<br>Lateral: ${lateralLength}</div>
                    `, { maxWidth: 250, className: 'high-z-popup' });
                    nearbyLateralsLayer.addLayer(line);
                });
            }

            // Show laterals only when zoomed in enough to see them
            const LATERAL_MIN_ZOOM = 12;
            function updateLateralVisibility() {
                const zoom = map.getZoom();
                if (zoom >= LATERAL_MIN_ZOOM && lateralData.length > 0) {
                    if (nearbyLateralsLayer.getLayers().length === 0) {
                        buildNearbyLaterals();
                    }
                    if (!map.hasLayer(nearbyLateralsLayer)) {
                        map.addLayer(nearbyLateralsLayer);
                    }
                } else {
                    if (map.hasLayer(nearbyLateralsLayer)) {
                        map.removeLayer(nearbyLateralsLayer);
                    }
                }
            }

            // Remove previous zoom handler if any, then add new one
            if (window._nearbyZoomHandler) {
                map.off('zoomend', window._nearbyZoomHandler);
            }
            window._nearbyZoomHandler = updateLateralVisibility;
            map.on('zoomend', updateLateralVisibility);
            updateLateralVisibility(); // Apply immediately

            console.log(`${wells.length} nearby wells rendered, ${lateralData.length} laterals (zoom >= ${LATERAL_MIN_ZOOM})`);

            ensureLayerOrder();
            updateSearchIndex();
        }

