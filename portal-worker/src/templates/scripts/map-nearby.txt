        // Toggle nearby wells from D1 database
        function toggleNearbyWells() {
            console.log('toggleNearbyWells called');
            const select = document.getElementById('nearby-wells-select');
            const value = select.value;
            const countDiv = document.getElementById('nearbyWellsCount');
            const separatorDiv = document.getElementById('nearbyWellsSeparator');

            console.log('Nearby wells select value:', value);
            console.log('User properties count:', userProperties.length);

            // Update active state based on selection
            if (value !== 'off') {
                select.classList.add('active');
                if (countDiv) countDiv.style.display = 'flex';
                if (separatorDiv) separatorDiv.style.display = 'block';
                console.log('Calling loadNearbyWells...');
                loadNearbyWells();
            } else {
                select.classList.remove('active');
                if (nearbyWellsLayer && map.hasLayer(nearbyWellsLayer)) {
                    map.removeLayer(nearbyWellsLayer);
                }
                if (countDiv) countDiv.style.display = 'none';
                if (separatorDiv) separatorDiv.style.display = 'none';
                const filterPanel = document.getElementById('wellsFilterPanel');
                if (filterPanel) filterPanel.style.display = 'none';
                const wellCount = document.getElementById('nearbyWellCount');
                if (wellCount) wellCount.textContent = '0';
                // Remove nearby wells from search index
                updateSearchIndex();
            }
        }


        // Helper function to generate cache key
        function getWellsCacheKey(status) {
            // Include a hash of property IDs to invalidate when properties change
            const propertyIds = userProperties.map(p => p.id).sort().join(',');
            const propertyHash = btoa(propertyIds).substring(0, 8); // Short hash
            // Add version number to invalidate old caches
            const CACHE_VERSION = 'v9'; // Fixed nearby-wells to query one TRS at a time
            return `mw_nearby_wells_${status}_${propertyHash}_${CACHE_VERSION}`;
        }

        // Helper function to clear all nearby wells caches
        function clearNearbyWellsCache() {
            const keys = Object.keys(localStorage).filter(k => k.includes('mw_nearby_wells'));
            keys.forEach(k => localStorage.removeItem(k));
            console.log(`Cleared ${keys.length} nearby wells cache entries`);
        }

        // Make it available globally for debugging
        window.clearNearbyWellsCache = clearNearbyWellsCache;

        // Helper function to show loading overlay on map
        function showMapLoadingOverlay(message = 'Loading...') {
            // Show a lightweight loading indicator for nearby wells select
            const select = document.getElementById('nearby-wells-select');
            if (select) {
                select.classList.add('loading');
                select.classList.add('active'); // Keep orange styling
                // Store original option text and change to Loading...
                const selectedOption = select.options[select.selectedIndex];
                select.setAttribute('data-original-text', selectedOption.text);
                selectedOption.text = 'Loading...';
            }
        }

        function hideMapLoadingOverlay() {
            // Remove loading state from nearby wells select
            const select = document.getElementById('nearby-wells-select');
            if (select) {
                select.classList.remove('loading');
                // Restore original option text
                const originalText = select.getAttribute('data-original-text');
                if (originalText) {
                    select.options[select.selectedIndex].text = originalText;
                    select.removeAttribute('data-original-text');
                }
            }
        }

        // Load wells from D1 database based on user properties (3x3 sections)
        async function loadNearbyWells() {
            console.log('loadNearbyWells started');
            console.log('userProperties:', userProperties);

            // Ensure we have user properties
            if (!userProperties || userProperties.length === 0) {
                console.error('No user properties loaded yet');
                updateStatus('No properties found - please refresh the page');
                return;
            }

            try {
                // Get status filter from the dropdown
                const statusFilter = document.getElementById('nearby-wells-select').value;
                console.log('Status filter value:', statusFilter);
                if (statusFilter === 'off') {
                    console.log('Nearby wells is off, not loading');
                    return;
                }
                const statusText = statusFilter === 'AC' ? 'active' : 'all';
                const cacheKey = getWellsCacheKey(statusFilter);

                // Check cache first
                const cachedData = localStorage.getItem(cacheKey);
                if (cachedData) {
                    try {
                        const cached = JSON.parse(cachedData);
                        const cacheAge = Date.now() - cached.timestamp;
                        const MAX_CACHE_AGE = 24 * 60 * 60 * 1000; // 24 hours

                        // Don't use cache if it's empty or too old
                        if (cacheAge < MAX_CACHE_AGE && cached.wells && cached.wells.length > 0) {
                            console.log(`Using cached ${statusText} wells data (${Math.round(cacheAge / 1000 / 60)} minutes old)`);
                            allNearbyWells = cached.wells;
                            const filteredWells = filterWellsData(cached.wells);
                            displayFilteredWells(filteredWells);
                            updateStatus(`Displayed ${cached.wells.length} ${statusText} wells (from cache)`);
                            return;
                        } else if (cached.wells && cached.wells.length === 0) {
                            console.log('Cache contains 0 wells, invalidating and fetching fresh data');
                            localStorage.removeItem(cacheKey);
                        }
                    } catch (e) {
                        console.error('Failed to parse cached data:', e);
                        localStorage.removeItem(cacheKey);
                    }
                }

                // Show loading overlay
                showMapLoadingOverlay(`Loading ${statusText} wells...`);
                updateStatus('Loading nearby wells...');

                // Get TRS sections for all user properties and their 3x3 neighbors
                const propertySections = await getPropertyNearbySections();

                if (propertySections.length === 0) {
                    hideMapLoadingOverlay();
                    updateStatus('No properties found');
                    return;
                }

                console.log(`Loading ${statusText} wells for ${propertySections.length} sections (3x3 around properties)`);
                console.log('First 5 property sections:', propertySections.slice(0, 5)); // Log first 5 for debugging
                console.log('Sample TRS format:', propertySections[0]); // Show exact format

                // No limit needed - backend handles chunking
                const sectionsToQuery = propertySections;

                // Make single POST request with all TRS values
                const requestBody = {
                    trs: sectionsToQuery,
                    status: statusFilter.toLowerCase(), // Send 'ac', 'pa', or 'all'
                    limit: 20000 // Higher limit to get all wells
                };

                console.log('Sending POST request with body:', requestBody);

                const response = await fetch('/api/nearby-wells', {
                    method: 'POST',
                    credentials: 'include',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    hideMapLoadingOverlay();
                    const errorText = await response.text();
                    console.error('Failed to load wells:', response.status, response.statusText, errorText);
                    updateStatus('Failed to load wells');
                    return;
                }

                const result = await response.json();
                console.log('API response:', result);
                const allWells = result.data?.wells || [];
                console.log(`Received ${allWells.length} wells from API (3x3 search)`);

                // Debug: Log first few wells to see exact field names
                if (allWells.length > 0) {
                    console.log('First well structure:', allWells[0]);
                    console.log('First well keys:', Object.keys(allWells[0]));
                }

                // Debug: Check if operator data exists in response
                const wellsWithOperatorInfo = allWells.filter(w => w.phone || w.operator_phone || w.contact_name);
                console.log(`Wells with operator info: ${wellsWithOperatorInfo.length}/${allWells.length}`);
                if (wellsWithOperatorInfo.length > 0) {
                    console.log('Sample well with operator info:', wellsWithOperatorInfo[0]);
                }

                // Additional search: Look for long lateral wells in a wider area (5x5)
                // This catches wells that start further away but might extend into properties
                const extendedSections = new Set();

                for (const property of userProperties) {
                    const fields = property.fields || property;
                    const section = parseInt(fields.SEC || fields.Section);
                    let township = (fields.TWN || fields.Township || '').replace(/\s+/g, '').toUpperCase();
                    let range = (fields.RNG || fields.Range || '').replace(/\s+/g, '').toUpperCase();
                    township = township.replace(/^T/, '');
                    range = range.replace(/^R/, '');
                    const meridian = fields.MERIDIAN || 'IM';

                    if (section && township && range) {
                        // Get 5x5 sections for wells with long laterals
                        const extendedNearbySections = get5x5Sections(section, township, range, meridian);
                        extendedNearbySections.forEach(trs => {
                            // Only add if not already in our 3x3 search
                            if (!sectionsToQuery.includes(trs)) {
                                extendedSections.add(trs);
                            }
                        });
                    }
                }

                if (extendedSections.size > 0) {
                    console.log(`Searching additional ${extendedSections.size} sections for long lateral wells...`);
                    updateStatus('Searching for extended lateral wells...');

                    try {
                        const extendedRequestBody = {
                            trs: Array.from(extendedSections),
                            status: statusFilter.toLowerCase(),
                            limit: 5000,
                            lateralOnly: true // We'll filter for long laterals on the frontend
                        };

                        const extendedResponse = await fetch('/api/nearby-wells', {
                            method: 'POST',
                            credentials: 'include',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(extendedRequestBody)
                        });

                        if (extendedResponse.ok) {
                            const extendedResult = await extendedResponse.json();
                            const extendedWells = (extendedResult.data?.wells || []).filter(well => {
                                // Only include wells with significant laterals (> 1 mile = 5280 ft)
                                return well.lateral_length && well.lateral_length > 5280 &&
                                       well.bh_latitude && well.bh_longitude;
                            });

                            console.log(`Found ${extendedWells.length} wells with long laterals in extended area`);

                            // Mark these wells so we can style them differently
                            extendedWells.forEach(well => {
                                well.isExtendedLateral = true;
                            });

                            // Combine with existing wells
                            allWells.push(...extendedWells);
                        }
                    } catch (error) {
                        console.warn('Error loading extended lateral wells:', error);
                        // Continue without extended wells
                    }
                }

                // Remove duplicates (wells might appear in multiple sections)
                const uniqueWells = Array.from(
                    new Map(allWells.map(w => [w.api_number, w])).values()
                );
                console.log(`After removing duplicates: ${uniqueWells.length} unique wells`);

                // Cache the results
                try {
                    localStorage.setItem(cacheKey, JSON.stringify({
                        wells: uniqueWells,
                        timestamp: Date.now()
                    }));
                    console.log(`Cached ${uniqueWells.length} ${statusText} wells`);
                } catch (e) {
                    console.error('Failed to cache wells:', e);
                    // Clear old cache if storage is full
                    try {
                        const keys = Object.keys(localStorage);
                        keys.filter(k => k.startsWith('mw_nearby_wells_')).forEach(k => {
                            localStorage.removeItem(k);
                        });
                    } catch (clearError) {
                        console.error('Failed to clear old cache:', clearError);
                    }
                }

                // Store wells for filtering
                allNearbyWells = uniqueWells;

                // Display wells (respecting any active filters)
                const filteredWells = filterWellsData(uniqueWells);
                console.log(`After filtering: ${filteredWells.length} wells to display`);
                displayFilteredWells(filteredWells);

                // Hide loading indicator after wells are displayed
                hideMapLoadingOverlay();

                // Update status
                if (filteredWells.length < uniqueWells.length) {
                    const filterCount = Object.values(wellsFilterState).filter(v => v).length;
                    updateStatus(`Loaded ${uniqueWells.length} wells, showing ${filteredWells.length} (${filterCount} filters active)`);
                } else {
                    updateStatus(`Loaded ${uniqueWells.length} wells from D1 database`);
                }

                // Clear status after delay
                setTimeout(() => updateStatus('Map ready'), 3000);

            } catch (error) {
                console.error('Error loading nearby wells:', error);
                hideMapLoadingOverlay();
                updateStatus('Failed to load wells');
                setTimeout(() => updateStatus('Map ready'), 3000);
            }
        }

        // Get 3x3 sections around user properties
        async function getPropertyNearbySections() {
            const sectionsSet = new Set();

            // For each property, get its section and 3x3 neighbors
            for (const property of userProperties) {
                const fields = property.fields || property;

                // Get property TRS
                const section = parseInt(fields.SEC || fields.Section);
                let township = (fields.TWN || fields.Township || '').replace(/\s+/g, '').toUpperCase();
                let range = (fields.RNG || fields.Range || '').replace(/\s+/g, '').toUpperCase();

                // Remove S/T/R prefixes if present
                township = township.replace(/^T/, '');
                range = range.replace(/^R/, '');

                // Get meridian - default to IM unless property has CM
                const meridian = fields.MERIDIAN || 'IM';

                // Log raw values for debugging
                console.log(`Property ${property.id}: Raw TWN="${fields.TWN || fields.Township}", RNG="${fields.RNG || fields.Range}", MERIDIAN="${meridian}"`);
                console.log(`Property ${property.id}: Parsed section=${section}, township=${township}, range=${range}, meridian=${meridian}`);

                if (!section || !township || !range) {
                    console.warn(`Property ${property.id} skipped - missing TRS data`);
                    continue;
                }

                // Get 3x3 sections around this property with proper meridian
                const nearbySections = get3x3Sections(section, township, range, meridian);
                nearbySections.forEach(trs => sectionsSet.add(trs));
            }

            return Array.from(sectionsSet);
        }

        // Get 3x3 grid of sections centered on given section
        function get3x3Sections(centerSection, township, range, meridian = 'IM') {
            const sections = [];

            // Standard 6x6 section layout
            const sectionGrid = [
                [6,  5,  4,  3,  2,  1],
                [7,  8,  9,  10, 11, 12],
                [18, 17, 16, 15, 14, 13],
                [19, 20, 21, 22, 23, 24],
                [30, 29, 28, 27, 26, 25],
                [31, 32, 33, 34, 35, 36]
            ];

            // Find center section position
            let centerRow = -1, centerCol = -1;
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 6; col++) {
                    if (sectionGrid[row][col] === centerSection) {
                        centerRow = row;
                        centerCol = col;
                        break;
                    }
                }
            }

            if (centerRow === -1) return [`${centerSection}-${township}-${range}-${meridian}`];

            // Get 3x3 grid (1 section in each direction)
            for (let row = Math.max(0, centerRow - 1); row <= Math.min(5, centerRow + 1); row++) {
                for (let col = Math.max(0, centerCol - 1); col <= Math.min(5, centerCol + 1); col++) {
                    const section = sectionGrid[row][col];
                    sections.push(`${section}-${township}-${range}-${meridian}`);
                }
            }

            return sections;
        }

        // Get 5x5 grid of sections centered on given section (for extended lateral search)
        function get5x5Sections(centerSection, township, range, meridian = 'IM') {
            const sections = [];

            // Standard 6x6 section layout
            const sectionGrid = [
                [6,  5,  4,  3,  2,  1],
                [7,  8,  9,  10, 11, 12],
                [18, 17, 16, 15, 14, 13],
                [19, 20, 21, 22, 23, 24],
                [30, 29, 28, 27, 26, 25],
                [31, 32, 33, 34, 35, 36]
            ];

            // Find center section position
            let centerRow = -1, centerCol = -1;
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 6; col++) {
                    if (sectionGrid[row][col] === centerSection) {
                        centerRow = row;
                        centerCol = col;
                        break;
                    }
                }
            }

            if (centerRow === -1) return [`${centerSection}-${township}-${range}-${meridian}`];

            // Get 5x5 grid (2 sections in each direction)
            for (let row = Math.max(0, centerRow - 2); row <= Math.min(5, centerRow + 2); row++) {
                for (let col = Math.max(0, centerCol - 2); col <= Math.min(5, centerCol + 2); col++) {
                    const section = sectionGrid[row][col];
                    sections.push(`${section}-${township}-${range}-${meridian}`);
                }
            }

            return sections;
        }

        // Parse PLSS ID to extract township/range
        function parsePlssId(plssId) {
            if (!plssId) return null;

            // Format: "OK170230N0080W0"
            const match = plssId.match(/OK\d{2}(\d{3})([NS])(\d{3})([EW])/);
            if (match) {
                const twpNum = parseInt(match[1], 10);
                const twpDir = match[2];
                const rngNum = parseInt(match[3], 10);
                const rngDir = match[4];

                return {
                    township: `${twpNum}${twpDir}`,
                    range: `${rngNum}${rngDir}`
                };
            }

            return null;
        }

        // No automatic refresh on map move - wells are loaded based on properties only

        // Wells filter state
        let wellsFilterState = {
            status: '',
            type: '',
            operator: '',
            county: ''
        };

        // All wells data (before filtering)
        let allNearbyWells = [];

        // Filter wells data based on current filter state
        function filterWellsData(wells) {
            return wells.filter(well => {
                // Status filter
                if (wellsFilterState.status && well.well_status !== wellsFilterState.status) {
                    return false;
                }

                // Type filter
                if (wellsFilterState.type && well.well_type !== wellsFilterState.type) {
                    return false;
                }

                // Operator filter (partial match)
                if (wellsFilterState.operator && !well.operator?.toLowerCase().includes(wellsFilterState.operator)) {
                    return false;
                }

                // County filter (partial match)
                if (wellsFilterState.county && !well.county?.toLowerCase().includes(wellsFilterState.county)) {
                    return false;
                }

                return true;
            });
        }

        // Toggle wells filter panel
        function toggleWellsFilter() {
            const panel = document.getElementById('wellsFilterPanel');
            const button = document.getElementById('filterToggleBtn');

            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                button.classList.add('active');
            } else {
                panel.style.display = 'none';
                button.classList.remove('active');
            }
        }

        // Apply wells filter
        function applyWellsFilter() {
            // Get filter values
            wellsFilterState.status = document.getElementById('filterWellStatus').value;
            wellsFilterState.type = document.getElementById('filterWellType').value;
            wellsFilterState.operator = document.getElementById('filterOperator').value.toLowerCase();
            wellsFilterState.county = document.getElementById('filterCounty').value.toLowerCase();

            // Filter wells
            const filteredWells = allNearbyWells.filter(well => {
                // Status filter
                if (wellsFilterState.status && well.well_status !== wellsFilterState.status) {
                    return false;
                }

                // Type filter
                if (wellsFilterState.type && well.well_type !== wellsFilterState.type) {
                    return false;
                }

                // Operator filter (partial match)
                if (wellsFilterState.operator && !well.operator?.toLowerCase().includes(wellsFilterState.operator)) {
                    return false;
                }

                // County filter (partial match)
                if (wellsFilterState.county && !well.county?.toLowerCase().includes(wellsFilterState.county)) {
                    return false;
                }

                return true;
            });

            // Update map
            displayFilteredWells(filteredWells);

            // Update status
            const filterCount = Object.values(wellsFilterState).filter(v => v).length;
            if (filterCount > 0) {
                updateStatus(`Showing ${filteredWells.length} of ${allNearbyWells.length} wells (${filterCount} filters active)`);
                document.getElementById('filterToggleBtn').innerHTML = '<span>üîç Filter Wells (' + filterCount + ')</span>';
            } else {
                updateStatus(`Showing all ${allNearbyWells.length} wells`);
                document.getElementById('filterToggleBtn').innerHTML = '<span>üîç Filter Wells</span>';
            }

            // Close panel
            toggleWellsFilter();
        }

        // Clear wells filter
        function clearWellsFilter() {
            // Reset form
            document.getElementById('filterWellStatus').value = '';
            document.getElementById('filterWellType').value = '';
            document.getElementById('filterOperator').value = '';
            document.getElementById('filterCounty').value = '';

            // Reset state
            wellsFilterState = {
                status: '',
                type: '',
                operator: '',
                county: ''
            };

            // Show all wells
            displayFilteredWells(allNearbyWells);
            updateStatus(`Showing all ${allNearbyWells.length} wells`);
            document.getElementById('filterToggleBtn').innerHTML = '<span>üîç Filter Wells</span>';

            // Close panel
            toggleWellsFilter();
        }

        // Display filtered wells on map
        function displayFilteredWells(wells) {
            // Initialize cluster group if not already done
            if (!nearbyWellsLayer) {
                nearbyWellsLayer = L.markerClusterGroup({
                    // Only cluster at zoom levels below 8 (was 9)
                    disableClusteringAtZoom: 8,
                    maxClusterRadius: 80,
                    spiderfyOnMaxZoom: true,
                    showCoverageOnHover: false,
                    zoomToBoundsOnClick: true,
                    // Custom cluster icon
                    iconCreateFunction: function(cluster) {
                        const count = cluster.getChildCount();
                        let size = 'small';
                        let className = 'marker-cluster-small';

                        if (count > 100) {
                            size = 'large';
                            className = 'marker-cluster-large';
                        } else if (count > 25) {
                            size = 'medium';
                            className = 'marker-cluster-medium';
                        }

                        return new L.DivIcon({
                            html: '<div><span>' + count + '</span></div>',
                            className: 'marker-cluster ' + className,
                            iconSize: new L.Point(40, 40)
                        });
                    }
                });
            }

            // Clear existing wells
            nearbyWellsLayer.clearLayers();

            // Build set of tracked well API numbers for fast lookup
            const trackedAPIs = new Set();
            if (trackedWells && trackedWells.length > 0) {
                trackedWells.forEach(well => {
                    const apiNumber = well.fields && well.fields['API Number'];
                    if (apiNumber) {
                        trackedAPIs.add(apiNumber);
                    }
                });
                console.log(`Filtering out ${trackedAPIs.size} tracked wells from nearby wells display`);
            }

            // Filter out tracked wells
            const untracked = wells.filter(well => {
                return !trackedAPIs.has(well.api_number);
            });

            console.log(`Displaying ${untracked.length} untracked wells (filtered ${wells.length - untracked.length} tracked wells)`);
            wells = untracked;

            // Update nearby wells count
            document.getElementById('nearbyWellCount').textContent = wells.length;

            // Fixed size for nearby wells - 60% of tracked well base size
            // No zoom-dependent scaling so they're consistent regardless of when you turn them on
            const nearbyWellSize = 14; // 60% of tracked wells (24px base)

            // Store wells data globally for popup access
            window.nearbyWellsData = {};

            // Track lateral statistics
            let lateralStats = {
                total: 0,
                drawn: 0,
                filteredOut: 0
            };

            // Add filtered wells to map
            wells.forEach(well => {
                // Store well data by API number
                if (well.api_number) {
                    window.nearbyWellsData[well.api_number] = well;
                }
                if (well.latitude && well.longitude) {
                    // Different styling for extended lateral wells
                    const isExtendedLateral = well.isExtendedLateral;
                    const markerColor = isExtendedLateral ? '#F59E0B' : '#9CA3AF'; // Amber for extended laterals
                    const strokeColor = isExtendedLateral ? '#D97706' : '#6B7280';
                    const centerColor = isExtendedLateral ? '#D97706' : '#6B7280';

                    // Create marker
                    const marker = L.marker([well.latitude, well.longitude], {
                        icon: L.divIcon({
                            className: 'nearby-well-marker' + (isExtendedLateral ? ' extended-lateral' : ''),
                            html: `
                                <svg width="${nearbyWellSize}" height="${nearbyWellSize * 1.4}" viewBox="-1 -1 26 35" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 1C5.9 1 1 5.9 1 12c0 8.5 11 19 11 19s11-10.5 11-19c0-6.1-4.9-11-11-11z"
                                          fill="${markerColor}" stroke="${strokeColor}" stroke-width="2"/>
                                    <circle cx="12" cy="12" r="4.5" fill="${centerColor}"/>
                                    ${isExtendedLateral ? '<text x="12" y="16" text-anchor="middle" fill="white" font-size="10" font-weight="bold">L</text>' : ''}
                                </svg>
                            `,
                            iconSize: [nearbyWellSize, nearbyWellSize * 1.4],
                            iconAnchor: [nearbyWellSize/2, nearbyWellSize * 1.4],
                            popupAnchor: [0, -nearbyWellSize * 1.4]
                        })
                    });

                    // Create small popup similar to tracked wells
                    const wellBaseName = well.well_name || 'Unnamed Well';
                    const wellNumber = well.well_number || '';
                    const wellName = toTitleCase(wellNumber ? `${wellBaseName} ${wellNumber}` : wellBaseName);
                    const operator = toTitleCase(well.operator || 'Unknown');
                    const operatorPhone = well.phone || well.operator_phone || '';
                    const contactName = toTitleCase(well.contact_name || '');

                    // Debug: Log first few wells to check operator data
                    if (Object.keys(window.nearbyWellsData).length < 3 && (operatorPhone || contactName)) {
                        console.log(`Nearby well ${well.api_number} operator data:`, {
                            operator: well.operator,
                            phone: well.phone,
                            operator_phone: well.operator_phone,
                            contact_name: well.contact_name
                        });
                    }
                    const wellStatus = getStatusLabel(well.well_status);
                    const statusColor = WELL_STATUS_COLORS[well.well_status] || WELL_STATUS_COLORS.default;
                    const formation = well.formation_name ? toTitleCase(well.formation_name) : '';

                    // Store well data for the expand function
                    marker.wellData = well;

                    const popupContent = `
                        <div class="popup-header">
                            <span class="popup-tag" style="background: ${isExtendedLateral ? '#FEF3C7' : '#E5E7EB'}; color: ${isExtendedLateral ? '#92400E' : '#374151'};">
                                ${isExtendedLateral ? 'Extended Lateral' : 'Nearby Well'}
                            </span>
                        </div>
                        <div class="popup-well-name">${wellName}</div>
                        <div class="popup-details">
                            ${operator}<br>
                            S${well.section} T${well.township} R${well.range} ‚Ä¢ ${toTitleCase(well.county || 'Unknown')}<br>
                            Status: ${wellStatus}${formation ? ` ‚Ä¢ ${formation}` : ''}
                            ${isExtendedLateral && well.lateral_length ? `<br>Lateral: ${(well.lateral_length / 5280).toFixed(1)} miles` : ''}
                        </div>
                        <div class="popup-actions">
                            <button class="popup-btn popup-btn-secondary" data-api="${well.api_number}" onclick="expandNearbyWellCard(nearbyWellsData['${well.api_number}']); return false;">More ‚Üí</button>
                        </div>
                    `;

                    marker.bindPopup(popupContent, {
                        maxWidth: 350,
                        className: 'high-z-popup'
                    });

                    nearbyWellsLayer.addLayer(marker);

                    // Check if this well has bottom hole coordinates for lateral drawing
                    if (well.bh_latitude && well.bh_longitude &&
                        (well.bh_latitude !== well.latitude || well.bh_longitude !== well.longitude)) {

                        lateralStats.total++;

                        // Calculate approximate distance to filter out bad data
                        const latDiff = Math.abs(well.bh_latitude - well.latitude);
                        const lngDiff = Math.abs(well.bh_longitude - well.longitude);
                        const approxDistanceMiles = (latDiff + lngDiff) * 69; // Very rough approximation

                        // Only draw laterals that are reasonable length (< 3 miles)
                        if (approxDistanceMiles < 3) {
                            // Draw lateral line
                            const lateralPath = drawLateralPath(
                                { lat: well.latitude, lng: well.longitude },
                                { lat: well.bh_latitude, lng: well.bh_longitude },
                                {
                                    fields: {
                                        'Well Name': well.well_name,
                                        'API Number': well.api_number,
                                        'Operator': well.operator,
                                        'Well Status': well.well_status,
                                        'Formation': well.formation_name,
                                        'wellName': well.well_name,
                                        'operator': well.operator,
                                        'formation': well.formation_name
                                    }
                                },
                                'nearby'
                            );

                            if (lateralPath) {
                                // Add lateral to the same layer group as the wells
                                nearbyWellsLayer.addLayer(lateralPath);
                                lateralStats.drawn++;
                            }
                        } else {
                            lateralStats.filteredOut++;
                            if (lateralStats.filteredOut <= 5) {  // Log first few filtered wells
                                console.log(`Filtered out lateral for ${well.well_name} (${well.api_number}): ~${approxDistanceMiles.toFixed(1)} miles`);
                            }
                        }
                    }
                }
            });

            // Ensure layers are on map
            if (!map.hasLayer(nearbyWellsLayer) && nearbyWellsLayer.getLayers().length > 0) {
                map.addLayer(nearbyWellsLayer);
            }

            // Log lateral statistics
            if (lateralStats.total > 0) {
                console.log(`Lateral lines: ${lateralStats.drawn} drawn, ${lateralStats.filteredOut} filtered out (too long), ${lateralStats.total} total with BH coords`);
            }

            ensureLayerOrder();

            // Rebuild search index to include/exclude nearby wells
            updateSearchIndex();
        }

