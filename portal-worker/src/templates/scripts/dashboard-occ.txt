        // OCC Filings Functions

        // State tracking for OCC filing processing
        const occProcessingStates = {}; // { stateKey: { status, documentId, buttonEl, pollInterval } }
        const OCC_POLL_INTERVAL = 5000; // 5 seconds
        const OCC_MAX_POLL_DURATION = 5 * 60 * 1000; // 5 minutes

        // Client-side cache for analyzed filings (persists across modal opens)
        // OCC filings: { caseNumber: { documentId, displayName } }
        // Completion reports: { entryId: { documentId, displayName } }
        const analyzedFilingsCache = {};
        const analyzedCompletionsCache = {};

        async function processOccFiling(caseNumber, orderNumber, buttonEl, force = false) {
            const stateKey = orderNumber || caseNumber;
            console.log(`[OCC Process] Processing ${caseNumber} (order: ${orderNumber})${force ? ' (force re-analyze)' : ''}`);

            // Helper to get current button from state (after DOM updates)
            const getCurrentButton = () => occProcessingStates[stateKey]?.buttonEl || buttonEl;

            // Update button to fetching state
            occProcessingStates[stateKey] = { status: 'fetching', buttonEl };
            updateOccButtonState(buttonEl, 'fetching');

            try {
                const response = await fetch('/api/occ/fetch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ caseNumber, orderNumber, force })
                });

                const result = await response.json();
                const currentBtn = getCurrentButton();

                if (result.alreadyProcessed) {
                    console.log(`[OCC Process] Already processed: ${result.documentId}`);
                    occProcessingStates[stateKey] = { ...occProcessingStates[stateKey], status: 'complete', documentId: result.documentId };
                    // Cache for future modal opens
                    const caseNumClean = caseNumber?.replace(/^CD\s*/i, '');
                    const cacheEntry = { documentId: result.documentId, displayName: result.displayName };
                    analyzedFilingsCache[caseNumber] = cacheEntry;
                    analyzedFilingsCache[caseNumClean] = cacheEntry;
                    updateOccButtonState(currentBtn, 'complete', result.documentId, result.displayName);
                } else if (result.success) {
                    const docId = result.document.id;
                    const docStatus = result.document.status || 'pending';
                    console.log(`[OCC Process] Successfully queued: ${docId}, status: ${docStatus}`);

                    // Update credits display
                    if (typeof updateCreditsDisplay === 'function') {
                        updateCreditsDisplay(result.creditsRemaining);
                    }

                    // Check initial status and start polling if not complete
                    if (docStatus === 'complete') {
                        occProcessingStates[stateKey] = { ...occProcessingStates[stateKey], status: 'complete', documentId: docId };
                        // Cache for future modal opens
                        const caseNumClean = caseNumber?.replace(/^CD\s*/i, '');
                        const cacheEntry = { documentId: docId, displayName: result.document.display_name };
                        analyzedFilingsCache[caseNumber] = cacheEntry;
                        analyzedFilingsCache[caseNumClean] = cacheEntry;
                        updateOccButtonState(currentBtn, 'complete', docId);
                    } else {
                        // Start polling for document status
                        occProcessingStates[stateKey] = {
                            ...occProcessingStates[stateKey],
                            status: docStatus === 'processing' ? 'processing' : 'queued',
                            documentId: docId,
                            pollStartTime: Date.now()
                        };
                        updateOccButtonState(currentBtn, docStatus === 'processing' ? 'processing' : 'queued');
                        startOccDocumentPolling(stateKey, docId, getCurrentButton());
                    }
                } else if (result.error === 'no_credits') {
                    console.log(`[OCC Process] No credits available`);
                    occProcessingStates[stateKey] = { ...occProcessingStates[stateKey], status: 'idle' };
                    updateOccButtonState(currentBtn, 'idle');
                    showOutOfCreditsModal();
                } else {
                    throw new Error(result.message || result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('[OCC Process] Error:', error);
                const currentBtn = getCurrentButton();
                occProcessingStates[stateKey] = { ...occProcessingStates[stateKey], status: 'error' };
                updateOccButtonState(currentBtn, 'error');
                showToast('Failed to process filing: ' + error.message, 'error');
            }
        }
        window.processOccFiling = processOccFiling;

        // Wrapper for Activity Log - processes OCC filing by case number only
        async function processOccFilingFromActivity(caseNumber, buttonEl) {
            // Use empty order number - the OCC fetcher will find the latest order
            await processOccFiling(caseNumber, '', buttonEl);
        }
        window.processOccFilingFromActivity = processOccFilingFromActivity;

        function startOccDocumentPolling(stateKey, documentId, buttonEl) {
            const state = occProcessingStates[stateKey];
            if (!state || state.pollInterval) return; // Already polling

            console.log(`[OCC Poll] Starting polling for ${documentId}`);

            state.pollInterval = setInterval(async () => {
                const currentState = occProcessingStates[stateKey];
                if (!currentState) {
                    clearInterval(state.pollInterval);
                    return;
                }

                // Always use the fresh button reference from state (it gets updated when DOM changes)
                const currentButtonEl = currentState.buttonEl;

                // Check if we've exceeded max poll duration
                if (Date.now() - currentState.pollStartTime > OCC_MAX_POLL_DURATION) {
                    console.log(`[OCC Poll] Max duration exceeded for ${documentId}`);
                    clearInterval(currentState.pollInterval);
                    currentState.pollInterval = null;
                    // Leave in current state - user can check documents tab
                    return;
                }

                try {
                    const response = await fetch(`/api/documents/${documentId}`, {
                        credentials: 'include'
                    });

                    if (!response.ok) {
                        console.log(`[OCC Poll] Error fetching status for ${documentId}`);
                        return;
                    }

                    const data = await response.json();
                    const doc = data.document;

                    if (!doc) return;

                    console.log(`[OCC Poll] Document ${documentId} status: ${doc.status}`);

                    if (doc.status === 'complete') {
                        // Document processing complete!
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'complete';
                        // Cache for future modal opens (stateKey is caseNumber or orderNumber)
                        const caseNumClean = stateKey?.replace(/^CD\s*/i, '');
                        const cacheEntry = { documentId: documentId, displayName: doc.display_name };
                        analyzedFilingsCache[stateKey] = cacheEntry;
                        analyzedFilingsCache[caseNumClean] = cacheEntry;
                        updateOccButtonState(currentButtonEl, 'complete', documentId, doc.display_name);
                        showToast('Document analysis complete!', 'success');
                        loadUsageStats(); // Refresh credits after processing complete
                    } else if (doc.status === 'processing' && currentState.status !== 'processing') {
                        // Transitioned to processing
                        currentState.status = 'processing';
                        updateOccButtonState(currentButtonEl, 'processing');
                    } else if (doc.status === 'error') {
                        // Processing failed
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'error';
                        updateOccButtonState(currentButtonEl, 'error');
                        showToast('Document processing failed', 'error');
                    }
                } catch (err) {
                    console.error(`[OCC Poll] Error polling ${documentId}:`, err);
                }
            }, OCC_POLL_INTERVAL);
        }

        function stopAllOccPolling() {
            for (const key in occProcessingStates) {
                const state = occProcessingStates[key];
                if (state.pollInterval) {
                    clearInterval(state.pollInterval);
                    state.pollInterval = null;
                }
            }
        }

        function updateOccButtonState(buttonEl, state, documentId = null, displayName = null) {
            if (!buttonEl) return;

            // Get parent container - this stays in the DOM even when we replace innerHTML
            // If buttonEl is already detached, try to find container via stateKey
            let parentContainer = buttonEl.parentElement;
            let caseNumber = buttonEl.dataset?.caseNumber || '';
            let orderNumber = buttonEl.dataset?.orderNumber || '';

            // If buttonEl is detached (parentElement is null), we can't update
            if (!parentContainer) {
                console.warn('[OCC] Button element is detached from DOM, cannot update state');
                return;
            }

            // For states that need a single button (not complete), replace container with occ-process-btn
            const createProcessButton = (stateClass, disabled, innerHTML, title) => {
                parentContainer.innerHTML = `
                    <button class="occ-process-btn ${stateClass}"
                            data-case-number="${escapeHtml(caseNumber)}"
                            data-order-number="${escapeHtml(orderNumber)}"
                            ${disabled ? 'disabled' : ''}
                            onclick="processOccFiling('${escapeHtml(caseNumber)}', '${escapeHtml(orderNumber)}', this)"
                            title="${title}">${innerHTML}</button>
                `;
                // Return the new button for reference updates
                return parentContainer.querySelector('button');
            };

            let newButton = null;
            switch (state) {
                case 'fetching':
                    newButton = createProcessButton('fetching', true, '<span class="spinner-sm"></span> Fetching...', 'Downloading from OCC');
                    break;
                case 'queued':
                    newButton = createProcessButton('queued', true, '<span class="spinner-sm"></span> Queued...', 'Waiting for processing');
                    break;
                case 'processing':
                    newButton = createProcessButton('processing', true, '<span class="spinner-sm"></span> Processing...', 'Extracting document data');
                    break;
                case 'complete':
                    if (documentId) {
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    data-case-number="${escapeHtml(caseNumber)}"
                                    data-order-number="${escapeHtml(orderNumber)}"
                                    onclick="processOccFiling('${escapeHtml(caseNumber)}', '${escapeHtml(orderNumber)}', this, true)"
                                    title="Re-process this document (uses 1 credit)">Re-analyze</button>
                            <button class="occ-view-doc-btn"
                                    onclick="openDocumentDetail('${documentId}')"
                                    title="View analyzed document">View Doc ↗</button>
                        `;
                        newButton = parentContainer.querySelector('button');
                    } else {
                        newButton = createProcessButton('complete', false, '✓ Analyzed', 'Click to view document');
                    }
                    break;
                case 'error':
                    newButton = createProcessButton('error', false, 'Retry', 'Click to retry');
                    break;
                default: // idle
                    newButton = createProcessButton('', false, 'Analyze', 'Uses 1 document credit');
            }

            // Update the state tracking with the new button reference
            const stateKey = orderNumber || caseNumber;
            if (stateKey && occProcessingStates[stateKey] && newButton) {
                occProcessingStates[stateKey].buttonEl = newButton;
            }
        }

        function toggleOccFilings(type) {
            const content = document.getElementById(type === 'property' ? 'property-occ-content' : 'well-occ-content');
            const arrow = document.getElementById(type === 'property' ? 'property-occ-arrow' : 'well-occ-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }
        window.toggleOccFilings = toggleOccFilings;

        // Toggle Well Records section (completion reports)
        function toggleWellRecords() {
            const content = document.getElementById('well-records-content');
            const arrow = document.getElementById('well-records-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }
        window.toggleWellRecords = toggleWellRecords;

        // Load Well Records (completion reports) - called when well modal opens
        async function loadWellRecords(apiNumber) {
            console.log('[WellRecords] Loading completion reports for API:', apiNumber);
            const countBadge = document.getElementById('well-records-count');
            const container = document.getElementById('well-records-container');

            try {
                const response = await fetch(`/api/wells/${apiNumber}/completion-reports`, {
                    credentials: 'include'
                });
                const data = await response.json();
                const completionReports = data.completionReports || [];

                console.log('[WellRecords] Loaded:', completionReports.length, 'reports');

                // Update count badge (remove loading class, show count)
                countBadge.className = '';
                countBadge.style.cssText = 'background: #e5e7eb; padding: 2px 8px; border-radius: 12px; font-size: 12px;';
                countBadge.textContent = completionReports.length;

                if (completionReports.length === 0) {
                    container.innerHTML = '<div style="color: #6b7280; font-size: 13px; font-style: italic; padding: 8px 0;">No completion reports found</div>';
                    return;
                }

                // Sort by effective date (newest first)
                completionReports.sort((a, b) => {
                    const dateA = parseCompletionDate(a.effectiveDate);
                    const dateB = parseCompletionDate(b.effectiveDate);
                    return dateB - dateA;
                });

                // Render completion reports
                const html = completionReports.map((report, idx) => {
                    const isCurrent = idx === 0; // Most recent is "current"
                    return renderCompletionReport(report, apiNumber, isCurrent);
                }).join('');

                container.innerHTML = html;
            } catch (error) {
                console.error('[WellRecords] Error loading completion reports:', error);
                countBadge.className = '';
                countBadge.style.cssText = 'background: #fecaca; padding: 2px 8px; border-radius: 12px; font-size: 12px; color: #dc2626;';
                countBadge.textContent = '!';
                container.innerHTML = '<div style="color: #ef4444; font-size: 13px; padding: 8px 0;">Error loading completion reports</div>';
            }
        }
        window.loadWellRecords = loadWellRecords;

        async function loadOccFilings(section, township, range, type = 'property', meridian = 'IM', apiNumber = null) {
            console.log(`[OccFilings] Loading filings for S${section}-T${township}-R${range} ${meridian} (${type})${apiNumber ? ` API: ${apiNumber}` : ''}`);

            const prefix = type === 'property' ? 'property' : 'well';
            const directContainer = document.getElementById(`${prefix}-occ-direct`);
            const adjacentContainer = document.getElementById(`${prefix}-occ-adjacent`);
            const adjacentWrapper = document.getElementById(`${prefix}-occ-adjacent-wrapper`);
            const emptyMessage = document.getElementById(`${prefix}-occ-empty`);
            const countBadge = document.getElementById(`${prefix}-occ-count`);
            const adjacentCountBadge = document.getElementById(`${prefix}-occ-adjacent-count`);

            // Reset
            directContainer.innerHTML = '<div style="padding: 12px; color: #6b7280;">Loading filings...</div>';
            adjacentContainer.innerHTML = '';
            adjacentWrapper.style.display = 'none';
            emptyMessage.style.display = 'none';
            countBadge.textContent = '—';

            try {
                let directFilings = [];
                let adjacentFilings = [];
                let punInfo = null;

                // For wells, use PUN-scoped endpoint (no adjacent sections)
                // For properties, use TRS-based endpoint with adjacent sections
                if (type === 'well' && apiNumber) {
                    const docketResponse = await fetch(
                        `/api/docket-entries-by-well?api=${encodeURIComponent(apiNumber)}`,
                        { credentials: 'include' }
                    );
                    const data = await docketResponse.json();

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to load filings');
                    }

                    directFilings = data.direct || [];
                    punInfo = data.pun ? `Unit: ${data.pun} (${data.wellCount} wells, ${data.trsCount || 1} sections)` : null;
                    // No adjacent filings for wells - we show all sections in the unit as "direct"
                } else {
                    // Properties: use TRS-based query with adjacent sections
                    const docketResponse = await fetch(
                        `/api/docket-entries?section=${section}&township=${encodeURIComponent(township)}&range=${encodeURIComponent(range)}&meridian=${encodeURIComponent(meridian)}&includeAdjacent=true`,
                        { credentials: 'include' }
                    );
                    const data = await docketResponse.json();

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to load filings');
                    }

                    directFilings = data.direct || [];
                    adjacentFilings = data.adjacent || [];
                }

                // Show docket entries immediately (completion reports now handled separately in Well Records section)
                let docketCount = directFilings.length + adjacentFilings.length;

                // Build docket filings HTML
                let contentHtml = '';

                // Add OCC filings (completion reports are now in separate Well Records section)
                if (directFilings.length > 0) {
                    if (type === 'well' && apiNumber && punInfo) {
                        // Show PUN info for wells
                        contentHtml += `<div style="font-size: 11px; color: #6b7280; margin-bottom: 8px; padding: 4px 0;">${punInfo}</div>`;
                    }
                    contentHtml += directFilings.map(filing => renderOccFiling(filing, false)).join('');
                } else if (type === 'property') {
                    contentHtml = '<div style="color: #888; font-size: 13px; font-style: italic; padding: 8px 0;">No direct filings for this section</div>';
                } else if (type === 'well') {
                    contentHtml += '<div style="color: #888; font-size: 13px; font-style: italic; padding: 8px 0;">No OCC filings found for this unit</div>';
                }

                // Show docket entries immediately
                if (directFilings.length === 0 && adjacentFilings.length === 0 && type === 'property') {
                    directContainer.innerHTML = '';
                    emptyMessage.style.display = 'block';
                } else {
                    directContainer.innerHTML = contentHtml;
                    countBadge.textContent = String(docketCount);
                }

                // Render adjacent filings (only for properties now)
                if (adjacentFilings.length > 0) {
                    adjacentWrapper.style.display = 'block';
                    adjacentCountBadge.textContent = String(adjacentFilings.length);
                    adjacentContainer.innerHTML = adjacentFilings.map(filing => renderOccFiling(filing, true)).join('');
                }

                // Check which filings have already been analyzed (don't await - fire and forget)
                const allFilings = [...directFilings, ...adjacentFilings];
                const analyzableFilings = allFilings.filter(f =>
                    (f.status === 'HEARD' || f.status === 'RECOMMENDED') && f.caseNumber
                );

                if (analyzableFilings.length > 0) {
                    checkAnalyzedFilings(analyzableFilings);
                }

                // Note: Completion reports are now loaded separately via loadWellRecords() into the Well Records section

            } catch (error) {
                console.error('[OccFilings] Error loading filings:', error);
                directContainer.innerHTML = '<div style="color: #dc3545; font-size: 13px; padding: 8px 0;">Error loading filings</div>';
                countBadge.textContent = '0';
            }
        }

        // Background loader for completion reports (doesn't block modal)
        async function loadCompletionReportsAsync(apiNumber, docketCount, directFilingsCount, countBadge) {
            const reportsSection = document.getElementById('completion-reports-section');
            const reportsContent = document.getElementById('completion-reports-content');
            const reportsCountBadge = document.getElementById('completion-reports-count');

            try {
                console.log('[OccFilings] Fetching completion reports in background for:', apiNumber);
                const response = await fetch(`/api/wells/${apiNumber}/completion-reports`, { credentials: 'include' });
                const completionData = await response.json();
                const completionReports = completionData.completionReports || [];

                console.log('[OccFilings] Completion reports loaded:', completionReports.length);

                // Update the completion reports section
                if (reportsContent && reportsCountBadge) {
                    reportsCountBadge.textContent = String(completionReports.length);

                    if (completionReports.length > 0) {
                        // Sort by effective date (most recent first)
                        const sortedReports = [...completionReports].sort((a, b) => {
                            const dateA = parseCompletionDate(a.effectiveDate);
                            const dateB = parseCompletionDate(b.effectiveDate);
                            return dateB - dateA; // Most recent first
                        });

                        // Populate cache for already-analyzed reports
                        for (const report of sortedReports) {
                            if (report.documentId && (report.status === 'fetched' || report.status === 'processed')) {
                                analyzedCompletionsCache[report.entryId] = { documentId: report.documentId, displayName: report.wellName };
                            }
                        }

                        reportsContent.innerHTML = sortedReports.map((report, index) => renderCompletionReport(report, apiNumber, index === 0)).join('');
                    } else {
                        reportsContent.innerHTML = '<div style="color: #888; font-size: 13px; font-style: italic;">No completion reports found</div>';
                    }

                    // Update total count badge
                    const totalCount = docketCount + completionReports.length;
                    countBadge.textContent = String(totalCount);
                }
            } catch (err) {
                console.log('[OccFilings] Error fetching completion reports:', err);
                if (reportsContent && reportsCountBadge) {
                    reportsCountBadge.textContent = '0';
                    reportsContent.innerHTML = '<div style="color: #888; font-size: 13px; font-style: italic;">Could not load completion reports</div>';
                    countBadge.textContent = String(docketCount);
                }
            }
        }

        // Background checker for analyzed filings status
        async function checkAnalyzedFilings(analyzableFilings) {
            const caseNumbers = analyzableFilings.map(f => f.caseNumber).join(',');
            console.log('[OccFilings] Checking analyzed status for:', caseNumbers);

            try {
                const analyzedResponse = await fetch(
                    `/api/documents/by-occ-cases?cases=${encodeURIComponent(caseNumbers)}`,
                    { credentials: 'include' }
                );

                if (!analyzedResponse.ok) {
                    console.error('[OccFilings] API error:', analyzedResponse.status);
                    return;
                }

                const analyzedData = await analyzedResponse.json();

                // Update buttons for already-analyzed filings and populate cache
                for (const filing of analyzableFilings) {
                    const caseNum = filing.caseNumber;
                    const caseNumClean = caseNum?.replace(/^CD\s*/i, '');
                    const analyzed = analyzedData[caseNum] ||
                                   analyzedData[caseNumClean] ||
                                   analyzedData[`CD${caseNumClean}`];

                    if (analyzed) {
                        // Populate cache for future renders (use all case number variants)
                        const cacheEntry = { documentId: analyzed.documentId, displayName: analyzed.displayName };
                        analyzedFilingsCache[caseNum] = cacheEntry;
                        analyzedFilingsCache[caseNumClean] = cacheEntry;
                        analyzedFilingsCache[`CD${caseNumClean}`] = cacheEntry;

                        const buttonId = `occ-btn-${(filing.orderNumber || filing.caseNumber).replace(/[^a-zA-Z0-9]/g, '-')}`;
                        const button = document.getElementById(buttonId);
                        if (button) {
                            const stateKey = filing.orderNumber || filing.caseNumber;
                            occProcessingStates[stateKey] = { status: 'complete', documentId: analyzed.documentId, buttonEl: button };
                            updateOccButtonState(button, 'complete', analyzed.documentId, analyzed.displayName);
                        }
                    }
                }
            } catch (err) {
                console.log('[OccFilings] Could not check analyzed status:', err);
            }
        }
        window.loadOccFilings = loadOccFilings;

        function renderOccFiling(filing, isAdjacent = false) {
            const statusClass = getOccStatusClass(filing.status);
            const dateDisplay = formatOccDate(filing.hearingDate || filing.docketDate);
            const isUpcoming = isOccHearingUpcoming(filing.hearingDate, filing.status);

            let adjacentNote = '';
            if (isAdjacent && filing.section) {
                adjacentNote = `<span class="occ-adjacent-note">S${filing.section}-T${filing.township}-R${filing.range}</span>`;
            }

            // Show Analyze button for filings with final orders (HEARD/RECOMMENDED)
            const hasFinalOrder = filing.status === 'HEARD' || filing.status === 'RECOMMENDED';
            const orderNumber = filing.orderNumber || '';
            const caseNumber = filing.caseNumber || '';

            // Generate unique ID for the button
            const buttonId = `occ-btn-${(orderNumber || caseNumber).replace(/[^a-zA-Z0-9]/g, '-')}`;

            // Check cache for already-analyzed filings
            const caseNumClean = caseNumber?.replace(/^CD\s*/i, '');
            const cached = analyzedFilingsCache[caseNumber] || analyzedFilingsCache[caseNumClean] || analyzedFilingsCache[`CD${caseNumClean}`];

            let processButton = '';
            if (hasFinalOrder && caseNumber && cached) {
                // Already analyzed - show Re-analyze + View Doc immediately
                processButton = `
                    <div class="occ-filing-actions">
                        <button
                            id="${buttonId}"
                            class="occ-reanalyze-btn"
                            data-case-number="${escapeHtml(caseNumber)}"
                            data-order-number="${escapeHtml(orderNumber)}"
                            onclick="processOccFiling('${escapeHtml(caseNumber)}', '${escapeHtml(orderNumber)}', this, true)"
                            title="Re-process this document (uses 1 credit)"
                        >Re-analyze</button>
                        <button class="occ-view-doc-btn" onclick="openDocumentDetail('${cached.documentId}')" title="View analyzed document">View Doc ↗</button>
                    </div>
                `;
            } else if (hasFinalOrder && caseNumber) {
                processButton = `
                    <div class="occ-filing-actions">
                        <button
                            id="${buttonId}"
                            class="occ-process-btn"
                            data-case-number="${escapeHtml(caseNumber)}"
                            data-order-number="${escapeHtml(orderNumber)}"
                            onclick="processOccFiling('${escapeHtml(caseNumber)}', '${escapeHtml(orderNumber)}', this)"
                            title="Uses 1 document credit"
                        >Analyze</button>
                    </div>
                `;
            }

            return `
                <div class="occ-filing-item">
                    <div class="occ-filing-main">
                        <div class="occ-filing-type">
                            ${isUpcoming ? '<span class="occ-hearing-warning" title="Hearing within 30 days">⚠️</span>' : ''}
                            ${escapeHtml(filing.reliefTypeDisplay)}
                            ${adjacentNote}
                        </div>
                        <div class="occ-filing-applicant">${escapeHtml(filing.applicant) || 'Unknown Applicant'}</div>
                        <div class="occ-filing-details">
                            <span class="occ-filing-case">${escapeHtml(filing.caseNumber)}</span>
                            <span class="occ-filing-status ${statusClass}">${escapeHtml(filing.statusDisplay)}</span>
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                        <div class="occ-filing-date">
                            ${dateDisplay}
                        </div>
                        ${processButton}
                    </div>
                </div>
            `;
        }

        // Render completion report item (1002A/1002C forms)
        function renderCompletionReport(report, apiNumber, isCurrent = false) {
            const isRecompletion = report.formType === '1002C';
            const typeClass = isRecompletion ? 'recompletion' : 'completion';
            const typeLabel = isRecompletion ? 'RECOMPLETION 1002C' : 'COMPLETION 1002A';
            const dateDisplay = formatCompletionDate(report.effectiveDate);
            const buttonId = `completion-btn-${report.entryId}`;
            const isFailed = report.status === 'error';
            const currentBadge = isCurrent ? '<span class="completion-current-badge">Current</span>' : '';
            const failedBadge = isFailed ? `<span class="completion-failed-badge" title="${escapeHtml(report.errorMessage || 'Processing failed')}">Failed</span>` : '';

            // Check client-side cache first (for instant display on modal reopen)
            const cached = analyzedCompletionsCache[report.entryId];

            // Render action button based on status (or cache)
            let actionButton = '';
            if (cached && cached.documentId) {
                // Cached as analyzed - show Re-analyze + View Doc immediately
                actionButton = `
                    <button class="occ-reanalyze-btn"
                            data-api-number="${apiNumber}"
                            data-entry-id="${report.entryId}"
                            onclick="analyzeCompletion('${apiNumber}', ${report.entryId}, this, true)"
                            title="Re-process this document">Re-analyze</button>
                    <button class="occ-view-doc-btn" onclick="openDocumentDetail('${cached.documentId}')" title="View analyzed document">View Doc ↗</button>`;
            } else switch (report.status) {
                case 'available':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn"
                                data-api-number="${apiNumber}"
                                data-entry-id="${report.entryId}"
                                onclick="analyzeCompletion('${apiNumber}', ${report.entryId}, this)">
                            Analyze
                        </button>`;
                    break;
                case 'fetching':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn analyzing" disabled>
                            <span class="spinner-sm"></span>Analyzing...
                        </button>`;
                    break;
                case 'fetched':
                case 'processed':
                    actionButton = `
                        <button class="occ-reanalyze-btn"
                                data-api-number="${apiNumber}"
                                data-entry-id="${report.entryId}"
                                onclick="analyzeCompletion('${apiNumber}', ${report.entryId}, this, true)"
                                title="Re-process this document">Re-analyze</button>
                        ${report.documentId ? `<button class="occ-view-doc-btn" onclick="openDocumentDetail('${report.documentId}')" title="View analyzed document">View Doc ↗</button>` : ''}`;
                    break;
                case 'error':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn error"
                                onclick="analyzeCompletion('${apiNumber}', ${report.entryId}, this, true)"
                                title="${escapeHtml(report.errorMessage || 'Error occurred')}">
                            Retry
                        </button>`;
                    break;
                default:
                    actionButton = '<span style="color: #888; font-size: 12px;">—</span>';
            }

            return `
                <div class="completion-report-item${isCurrent ? ' is-current' : ''}${isFailed ? ' is-failed' : ''}">
                    <div class="completion-report-main">
                        <div>
                            <span class="completion-report-type ${typeClass}">${typeLabel}</span>
                            ${currentBadge}
                            ${failedBadge}
                            <span class="completion-report-location">${escapeHtml(report.location || '')}</span>
                        </div>
                        <div class="completion-report-details">
                            ${report.county ? `<span>${escapeHtml(report.county)} County</span>` : ''}
                            ${report.wellName ? `<span>• ${escapeHtml(report.wellName)}</span>` : ''}
                            ${report.pun ? `<span class="completion-report-pun">PUN: ${escapeHtml(report.pun)}</span>` : ''}
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                        <div class="completion-report-date">${dateDisplay}</div>
                        <div class="occ-filing-actions">
                            ${actionButton}
                        </div>
                    </div>
                </div>
            `;
        }

        // State tracking for completion report processing (mirrors OCC filing pattern)
        const completionProcessingStates = {}; // { entryId: { status, documentId, buttonEl, pollInterval } }
        const COMPLETION_POLL_INTERVAL = 5000; // 5 seconds
        const COMPLETION_MAX_POLL_DURATION = 5 * 60 * 1000; // 5 minutes

        // Analyze completion report - fetch and process 1002A/1002C form
        // Uses same pattern as processOccFiling for consistency
        // force: if true, re-analyze even if already processed (for Re-analyze button)
        async function analyzeCompletion(apiNumber, entryId, buttonEl, force = false) {
            console.log(`[CompletionReports] Analyzing ${apiNumber} entryId ${entryId}${force ? ' (force re-analyze)' : ''}`);

            // Helper to get current button from state (after DOM updates)
            const getCurrentButton = () => completionProcessingStates[entryId]?.buttonEl || buttonEl;

            // Update button to fetching state
            completionProcessingStates[entryId] = { status: 'fetching', buttonEl };
            updateCompletionButtonState(buttonEl, 'fetching');

            try {
                const response = await fetch('/api/occ/fetch-1002a', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ apiNumber, entryId, force })
                });

                const result = await response.json();
                const currentBtn = getCurrentButton();

                if (response.status === 401) {
                    completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'idle' };
                    updateCompletionButtonState(currentBtn, 'idle');
                    showToast('Please log in to analyze completion reports', 'error');
                    return;
                }

                if (result.alreadyProcessed) {
                    console.log(`[CompletionReports] Already processed: ${result.documentId}`);
                    completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'complete', documentId: result.documentId };
                    updateCompletionButtonState(currentBtn, 'complete', result.documentId, result.displayName);
                } else if (result.success) {
                    const docId = result.document.id;
                    const docStatus = result.document.status || 'pending';
                    console.log(`[CompletionReports] Successfully queued: ${docId}, status: ${docStatus}`);

                    // Update credits display
                    if (typeof updateCreditsDisplay === 'function') {
                        updateCreditsDisplay(result.creditsRemaining);
                    }

                    // Check initial status and start polling if not complete
                    if (docStatus === 'complete') {
                        completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'complete', documentId: docId };
                        // Cache for future modal opens
                        analyzedCompletionsCache[entryId] = { documentId: docId, displayName: result.document?.display_name };
                        updateCompletionButtonState(currentBtn, 'complete', docId);
                        showToast('Completion report analyzed!', 'success');
                        loadUsageStats(); // Refresh credits after processing complete
                    } else {
                        // Start polling for document status
                        completionProcessingStates[entryId] = {
                            ...completionProcessingStates[entryId],
                            status: docStatus === 'processing' ? 'processing' : 'queued',
                            documentId: docId,
                            pollStartTime: Date.now()
                        };
                        updateCompletionButtonState(currentBtn, docStatus === 'processing' ? 'processing' : 'queued');
                        startCompletionDocumentPolling(entryId, docId, getCurrentButton());
                    }
                } else if (result.error === 'no_credits') {
                    console.log(`[CompletionReports] No credits available`);
                    completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'idle' };
                    updateCompletionButtonState(currentBtn, 'idle');
                    showOutOfCreditsModal();
                } else {
                    throw new Error(result.message || result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('[CompletionReports] Error:', error);
                const currentBtn = getCurrentButton();
                completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'error' };
                updateCompletionButtonState(currentBtn, 'error');
                showToast('Failed to analyze: ' + error.message, 'error');
            }
        }
        window.analyzeCompletion = analyzeCompletion;

        function startCompletionDocumentPolling(entryId, documentId, buttonEl) {
            const state = completionProcessingStates[entryId];
            if (!state || state.pollInterval) return; // Already polling

            console.log(`[CompletionReports Poll] Starting polling for ${documentId}`);

            state.pollInterval = setInterval(async () => {
                const currentState = completionProcessingStates[entryId];
                if (!currentState) {
                    clearInterval(state.pollInterval);
                    return;
                }

                // Always use the fresh button reference from state (it gets updated when DOM changes)
                const currentButtonEl = currentState.buttonEl;

                // Check if we've exceeded max poll duration
                if (Date.now() - currentState.pollStartTime > COMPLETION_MAX_POLL_DURATION) {
                    console.log(`[CompletionReports Poll] Max duration exceeded for ${documentId}`);
                    clearInterval(currentState.pollInterval);
                    currentState.pollInterval = null;
                    return;
                }

                try {
                    const response = await fetch(`/api/documents/${documentId}`, {
                        credentials: 'include'
                    });

                    if (!response.ok) {
                        console.log(`[CompletionReports Poll] Error fetching status for ${documentId}`);
                        return;
                    }

                    const data = await response.json();
                    const doc = data.document;

                    if (!doc) return;

                    console.log(`[CompletionReports Poll] Document ${documentId} status: ${doc.status}`);

                    if (doc.status === 'complete') {
                        // Document processing complete!
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'complete';
                        // Cache for future modal opens
                        analyzedCompletionsCache[entryId] = { documentId: documentId, displayName: doc.display_name };
                        updateCompletionButtonState(currentButtonEl, 'complete', documentId, doc.display_name);
                        showToast('Completion report analyzed!', 'success');
                        loadUsageStats(); // Refresh credits after processing complete
                    } else if (doc.status === 'processing' && currentState.status !== 'processing') {
                        // Transitioned to processing
                        currentState.status = 'processing';
                        updateCompletionButtonState(currentButtonEl, 'processing');
                    } else if (doc.status === 'failed' || doc.status === 'error') {
                        // Processing failed
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'error';
                        updateCompletionButtonState(currentButtonEl, 'error');
                        showToast('Document processing failed', 'error');
                    }
                } catch (err) {
                    console.error(`[CompletionReports Poll] Error polling ${documentId}:`, err);
                }
            }, COMPLETION_POLL_INTERVAL);
        }

        function updateCompletionButtonState(buttonEl, state, documentId = null, displayName = null) {
            if (!buttonEl) return;

            // Get parent container - this stays in the DOM even when we replace innerHTML
            let parentContainer = buttonEl.parentElement;
            let apiNum = buttonEl.dataset?.apiNumber || '';
            let entryId = buttonEl.dataset?.entryId || '';

            // If buttonEl is detached (parentElement is null), we can't update
            if (!parentContainer) {
                console.warn('[Completion] Button element is detached from DOM, cannot update state');
                return;
            }

            // For states that need a single button (not complete), replace container with completion-analyze-btn
            const createAnalyzeButton = (stateClass, disabled, innerHTML, title) => {
                parentContainer.innerHTML = `
                    <button class="completion-analyze-btn ${stateClass}"
                            data-api-number="${escapeHtml(apiNum)}"
                            data-entry-id="${escapeHtml(entryId)}"
                            ${disabled ? 'disabled' : ''}
                            onclick="analyzeCompletion('${escapeHtml(apiNum)}', ${entryId}, this)"
                            title="${title}">${innerHTML}</button>
                `;
                // Return the new button for reference updates
                return parentContainer.querySelector('button');
            };

            let newButton = null;
            switch (state) {
                case 'fetching':
                    newButton = createAnalyzeButton('fetching', true, '<span class="spinner-sm"></span> Fetching...', 'Downloading from OCC');
                    break;
                case 'queued':
                    newButton = createAnalyzeButton('queued', true, '<span class="spinner-sm"></span> Queued...', 'Waiting for processing');
                    break;
                case 'processing':
                    newButton = createAnalyzeButton('processing', true, '<span class="spinner-sm"></span> Processing...', 'Extracting document data');
                    break;
                case 'complete':
                    if (documentId) {
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    data-api-number="${escapeHtml(apiNum)}"
                                    data-entry-id="${escapeHtml(entryId)}"
                                    onclick="analyzeCompletion('${escapeHtml(apiNum)}', ${entryId}, this, true)"
                                    title="Re-process this document">Re-analyze</button>
                            <button class="occ-view-doc-btn"
                                    onclick="openDocumentDetail('${documentId}')"
                                    title="View analyzed document">View Doc ↗</button>
                        `;
                        newButton = parentContainer.querySelector('button');
                    } else {
                        newButton = createAnalyzeButton('analyzed', false, '✓ Analyzed', 'Analyzed');
                    }
                    break;
                case 'error':
                    newButton = createAnalyzeButton('error', false, 'Retry', 'Click to retry');
                    break;
                case 'idle':
                default:
                    newButton = createAnalyzeButton('', false, 'Analyze', 'Uses 1 document credit');
                    break;
            }

            // Update the state tracking with the new button reference
            if (entryId && completionProcessingStates[entryId] && newButton) {
                completionProcessingStates[entryId].buttonEl = newButton;
            }
        }

        // OCC helpers (getOccStatusClass, formatOccDate, isOccHearingUpcoming,
        // formatCompletionDate, parseCompletionDate) are in shared-occ-helpers.txt
