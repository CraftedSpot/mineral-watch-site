        // OCC Filings Functions
        // (processOccFiling, processOccFilingFromActivity, renderOccFiling,
        //  updateOccButtonState, startOccDocumentPolling, checkAnalyzedFilings,
        //  stopAllOccPolling, occProcessingStates, analyzedFilingsCache
        //  are provided by shared-occ-filings.txt)

        // Client-side cache for completion reports (page-specific)
        const analyzedCompletionsCache = {};

        function toggleOccFilings(type) {
            const content = document.getElementById(type === 'property' ? 'property-occ-content' : 'well-occ-content');
            const arrow = document.getElementById(type === 'property' ? 'property-occ-arrow' : 'well-occ-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }
        window.toggleOccFilings = toggleOccFilings;

        // Toggle Well Records section (completion reports)
        function toggleWellRecords() {
            const content = document.getElementById('well-records-content');
            const arrow = document.getElementById('well-records-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }
        window.toggleWellRecords = toggleWellRecords;

        // Load Well Records (completion reports) - called when well modal opens
        async function loadWellRecords(apiNumber) {
            console.log('[WellRecords] Loading completion reports for API:', apiNumber);
            const countBadge = document.getElementById('well-records-count');
            const container = document.getElementById('well-records-container');

            try {
                const response = await fetch(`/api/wells/${apiNumber}/completion-reports`, {
                    credentials: 'include'
                });
                const data = await response.json();
                const completionReports = data.completionReports || [];

                console.log('[WellRecords] Loaded:', completionReports.length, 'reports');

                // Update count badge (remove loading class, show count)
                countBadge.className = '';
                countBadge.style.cssText = 'background: #e5e7eb; padding: 2px 8px; border-radius: 12px; font-size: 12px;';
                countBadge.textContent = completionReports.length;

                if (completionReports.length === 0) {
                    container.innerHTML = '<div style="color: #6b7280; font-size: 13px; font-style: italic; padding: 8px 0;">No completion reports found</div>';
                    return;
                }

                // Sort by effective date (newest first)
                completionReports.sort((a, b) => {
                    const dateA = parseCompletionDate(a.effectiveDate);
                    const dateB = parseCompletionDate(b.effectiveDate);
                    return dateB - dateA;
                });

                // Render completion reports
                const html = completionReports.map((report, idx) => {
                    const isCurrent = idx === 0; // Most recent is "current"
                    return renderCompletionReport(report, apiNumber, isCurrent);
                }).join('');

                container.innerHTML = html;
            } catch (error) {
                console.error('[WellRecords] Error loading completion reports:', error);
                countBadge.className = '';
                countBadge.style.cssText = 'background: #fecaca; padding: 2px 8px; border-radius: 12px; font-size: 12px; color: #dc2626;';
                countBadge.textContent = '!';
                container.innerHTML = '<div style="color: #ef4444; font-size: 13px; padding: 8px 0;">Error loading completion reports</div>';
            }
        }
        window.loadWellRecords = loadWellRecords;

        async function loadOccFilings(section, township, range, type = 'property', meridian = 'IM', apiNumber = null) {
            console.log(`[OccFilings] Loading filings for S${section}-T${township}-R${range} ${meridian} (${type})${apiNumber ? ` API: ${apiNumber}` : ''}`);

            const prefix = type === 'property' ? 'property' : 'well';
            const directContainer = document.getElementById(`${prefix}-occ-direct`);
            const adjacentContainer = document.getElementById(`${prefix}-occ-adjacent`);
            const adjacentWrapper = document.getElementById(`${prefix}-occ-adjacent-wrapper`);
            const emptyMessage = document.getElementById(`${prefix}-occ-empty`);
            const countBadge = document.getElementById(`${prefix}-occ-count`);
            const adjacentCountBadge = document.getElementById(`${prefix}-occ-adjacent-count`);

            // Reset
            directContainer.innerHTML = '<div style="padding: 12px; color: #6b7280;">Loading filings...</div>';
            adjacentContainer.innerHTML = '';
            adjacentWrapper.style.display = 'none';
            emptyMessage.style.display = 'none';
            countBadge.textContent = '—';

            try {
                let directFilings = [];
                let adjacentFilings = [];
                let punInfo = null;

                // For wells, use PUN-scoped endpoint (no adjacent sections)
                // For properties, use TRS-based endpoint with adjacent sections
                if (type === 'well' && apiNumber) {
                    const docketResponse = await fetch(
                        `/api/docket-entries-by-well?api=${encodeURIComponent(apiNumber)}`,
                        { credentials: 'include' }
                    );
                    const data = await docketResponse.json();

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to load filings');
                    }

                    directFilings = data.direct || [];
                    punInfo = data.pun ? `Unit: ${data.pun} (${data.wellCount} wells, ${data.trsCount || 1} sections)` : null;
                    // No adjacent filings for wells - we show all sections in the unit as "direct"
                } else {
                    // Properties: use TRS-based query with adjacent sections
                    const docketResponse = await fetch(
                        `/api/docket-entries?section=${section}&township=${encodeURIComponent(township)}&range=${encodeURIComponent(range)}&meridian=${encodeURIComponent(meridian)}&includeAdjacent=true`,
                        { credentials: 'include' }
                    );
                    const data = await docketResponse.json();

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to load filings');
                    }

                    directFilings = data.direct || [];
                    adjacentFilings = data.adjacent || [];
                }

                // Show docket entries immediately (completion reports now handled separately in Well Records section)
                let docketCount = directFilings.length + adjacentFilings.length;

                // Build docket filings HTML
                let contentHtml = '';

                // Add OCC filings (completion reports are now in separate Well Records section)
                if (directFilings.length > 0) {
                    if (type === 'well' && apiNumber && punInfo) {
                        // Show PUN info for wells
                        contentHtml += `<div style="font-size: 11px; color: #6b7280; margin-bottom: 8px; padding: 4px 0;">${punInfo}</div>`;
                    }
                    contentHtml += directFilings.map(filing => renderOccFiling(filing, false)).join('');
                } else if (type === 'property') {
                    contentHtml = '<div style="color: #888; font-size: 13px; font-style: italic; padding: 8px 0;">No direct filings for this section</div>';
                } else if (type === 'well') {
                    contentHtml += '<div style="color: #888; font-size: 13px; font-style: italic; padding: 8px 0;">No OCC filings found for this unit</div>';
                }

                // Show docket entries immediately
                if (directFilings.length === 0 && adjacentFilings.length === 0 && type === 'property') {
                    directContainer.innerHTML = '';
                    emptyMessage.style.display = 'block';
                    countBadge.textContent = '0';
                } else {
                    directContainer.innerHTML = contentHtml;
                    countBadge.textContent = String(docketCount);
                }

                // Render adjacent filings (only for properties now)
                if (adjacentFilings.length > 0) {
                    adjacentWrapper.style.display = 'block';
                    adjacentCountBadge.textContent = String(adjacentFilings.length);
                    adjacentContainer.innerHTML = adjacentFilings.map(filing => renderOccFiling(filing, true)).join('');
                }

                // Check which filings have already been analyzed (don't await - fire and forget)
                const allFilings = [...directFilings, ...adjacentFilings];
                const analyzableFilings = allFilings.filter(f =>
                    (f.status === 'HEARD' || f.status === 'RECOMMENDED') && f.caseNumber
                );

                if (analyzableFilings.length > 0) {
                    checkAnalyzedFilings(analyzableFilings);
                }

                // Note: Completion reports are now loaded separately via loadWellRecords() into the Well Records section

            } catch (error) {
                console.error('[OccFilings] Error loading filings:', error);
                directContainer.innerHTML = '<div style="color: #dc3545; font-size: 13px; padding: 8px 0;">Error loading filings</div>';
                countBadge.textContent = '0';
            }
        }

        // Background loader for completion reports (doesn't block modal)
        async function loadCompletionReportsAsync(apiNumber, docketCount, directFilingsCount, countBadge) {
            const reportsSection = document.getElementById('completion-reports-section');
            const reportsContent = document.getElementById('completion-reports-content');
            const reportsCountBadge = document.getElementById('completion-reports-count');

            try {
                console.log('[OccFilings] Fetching completion reports in background for:', apiNumber);
                const response = await fetch(`/api/wells/${apiNumber}/completion-reports`, { credentials: 'include' });
                const completionData = await response.json();
                const completionReports = completionData.completionReports || [];

                console.log('[OccFilings] Completion reports loaded:', completionReports.length);

                // Update the completion reports section
                if (reportsContent && reportsCountBadge) {
                    reportsCountBadge.textContent = String(completionReports.length);

                    if (completionReports.length > 0) {
                        // Sort by effective date (most recent first)
                        const sortedReports = [...completionReports].sort((a, b) => {
                            const dateA = parseCompletionDate(a.effectiveDate);
                            const dateB = parseCompletionDate(b.effectiveDate);
                            return dateB - dateA; // Most recent first
                        });

                        // Populate cache for already-analyzed reports
                        for (const report of sortedReports) {
                            if (report.documentId && (report.status === 'fetched' || report.status === 'processed')) {
                                analyzedCompletionsCache[report.entryId] = { documentId: report.documentId, displayName: report.wellName };
                            }
                        }

                        reportsContent.innerHTML = sortedReports.map((report, index) => renderCompletionReport(report, apiNumber, index === 0)).join('');
                    } else {
                        reportsContent.innerHTML = '<div style="color: #888; font-size: 13px; font-style: italic;">No completion reports found</div>';
                    }

                    // Update total count badge
                    const totalCount = docketCount + completionReports.length;
                    countBadge.textContent = String(totalCount);
                }
            } catch (err) {
                console.log('[OccFilings] Error fetching completion reports:', err);
                if (reportsContent && reportsCountBadge) {
                    reportsCountBadge.textContent = '0';
                    reportsContent.innerHTML = '<div style="color: #888; font-size: 13px; font-style: italic;">Could not load completion reports</div>';
                    countBadge.textContent = String(docketCount);
                }
            }
        }

        window.loadOccFilings = loadOccFilings;

        // Render completion report item (1002A/1002C forms)
        function renderCompletionReport(report, apiNumber, isCurrent = false) {
            const isRecompletion = report.formType === '1002C';
            const typeClass = isRecompletion ? 'recompletion' : 'completion';
            const typeLabel = isRecompletion ? 'RECOMPLETION 1002C' : 'COMPLETION 1002A';
            const dateDisplay = formatCompletionDate(report.effectiveDate);
            const buttonId = `completion-btn-${report.entryId}`;
            const isFailed = report.status === 'error';
            const currentBadge = isCurrent ? '<span class="completion-current-badge">Current</span>' : '';
            const failedBadge = isFailed ? `<span class="completion-failed-badge" title="${escapeHtml(report.errorMessage || 'Processing failed')}">Failed</span>` : '';

            // Check client-side cache first (for instant display on modal reopen)
            const cached = analyzedCompletionsCache[report.entryId];

            // Render action button based on status (or cache)
            let actionButton = '';
            if (cached && cached.documentId) {
                // Cached as analyzed - show Re-analyze + View Doc immediately
                actionButton = `
                    <button class="occ-reanalyze-btn"
                            data-api-number="${apiNumber}"
                            data-entry-id="${report.entryId}"
                            onclick="analyzeCompletion('${apiNumber}', ${report.entryId}, this, true)"
                            title="Re-process this document">Re-analyze</button>
                    <button class="occ-view-doc-btn" onclick="openDocumentDetail('${cached.documentId}')" title="View analyzed document">View Doc ↗</button>`;
            } else switch (report.status) {
                case 'available':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn"
                                data-api-number="${apiNumber}"
                                data-entry-id="${report.entryId}"
                                onclick="analyzeCompletion('${apiNumber}', ${report.entryId}, this)">
                            Analyze
                        </button>`;
                    break;
                case 'fetching':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn analyzing" disabled>
                            <span class="spinner-sm"></span>Analyzing...
                        </button>`;
                    break;
                case 'fetched':
                case 'processed':
                    actionButton = `
                        <button class="occ-reanalyze-btn"
                                data-api-number="${apiNumber}"
                                data-entry-id="${report.entryId}"
                                onclick="analyzeCompletion('${apiNumber}', ${report.entryId}, this, true)"
                                title="Re-process this document">Re-analyze</button>
                        ${report.documentId ? `<button class="occ-view-doc-btn" onclick="openDocumentDetail('${report.documentId}')" title="View analyzed document">View Doc ↗</button>` : ''}`;
                    break;
                case 'error':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn error"
                                onclick="analyzeCompletion('${apiNumber}', ${report.entryId}, this, true)"
                                title="${escapeHtml(report.errorMessage || 'Error occurred')}">
                            Retry
                        </button>`;
                    break;
                default:
                    actionButton = '<span style="color: #888; font-size: 12px;">—</span>';
            }

            return `
                <div class="completion-report-item${isCurrent ? ' is-current' : ''}${isFailed ? ' is-failed' : ''}">
                    <div class="completion-report-main">
                        <div>
                            <span class="completion-report-type ${typeClass}">${typeLabel}</span>
                            ${currentBadge}
                            ${failedBadge}
                            <span class="completion-report-location">${escapeHtml(report.location || '')}</span>
                        </div>
                        <div class="completion-report-details">
                            ${report.county ? `<span>${escapeHtml(report.county)} County</span>` : ''}
                            ${report.wellName ? `<span>• ${escapeHtml(report.wellName)}</span>` : ''}
                            ${report.pun ? `<span class="completion-report-pun">PUN: ${escapeHtml(report.pun)}</span>` : ''}
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                        <div class="completion-report-date">${dateDisplay}</div>
                        <div class="occ-filing-actions">
                            ${actionButton}
                        </div>
                    </div>
                </div>
            `;
        }

        // State tracking for completion report processing (mirrors OCC filing pattern)
        const completionProcessingStates = {}; // { entryId: { status, documentId, buttonEl, pollInterval } }
        const COMPLETION_POLL_INTERVAL = 5000; // 5 seconds
        const COMPLETION_MAX_POLL_DURATION = 5 * 60 * 1000; // 5 minutes

        // Analyze completion report - fetch and process 1002A/1002C form
        // Uses same pattern as processOccFiling for consistency
        // force: if true, re-analyze even if already processed (for Re-analyze button)
        async function analyzeCompletion(apiNumber, entryId, buttonEl, force = false) {
            console.log(`[CompletionReports] Analyzing ${apiNumber} entryId ${entryId}${force ? ' (force re-analyze)' : ''}`);

            // Helper to get current button from state (after DOM updates)
            const getCurrentButton = () => completionProcessingStates[entryId]?.buttonEl || buttonEl;

            // Update button to fetching state
            completionProcessingStates[entryId] = { status: 'fetching', buttonEl };
            updateCompletionButtonState(buttonEl, 'fetching');

            try {
                const response = await fetch('/api/occ/fetch-1002a', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ apiNumber, entryId, force })
                });

                const result = await response.json();
                const currentBtn = getCurrentButton();

                if (response.status === 401) {
                    completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'idle' };
                    updateCompletionButtonState(currentBtn, 'idle');
                    showToast('Please log in to analyze completion reports', 'error');
                    return;
                }

                if (result.alreadyProcessed) {
                    console.log(`[CompletionReports] Already processed: ${result.documentId}`);
                    completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'complete', documentId: result.documentId };
                    updateCompletionButtonState(currentBtn, 'complete', result.documentId, result.displayName);
                } else if (result.success) {
                    const docId = result.document.id;
                    const docStatus = result.document.status || 'pending';
                    console.log(`[CompletionReports] Successfully queued: ${docId}, status: ${docStatus}`);

                    // Update credits display
                    if (typeof updateCreditsDisplay === 'function') {
                        updateCreditsDisplay(result.creditsRemaining);
                    }

                    // Check initial status and start polling if not complete
                    if (docStatus === 'complete') {
                        completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'complete', documentId: docId };
                        // Cache for future modal opens
                        analyzedCompletionsCache[entryId] = { documentId: docId, displayName: result.document?.display_name };
                        updateCompletionButtonState(currentBtn, 'complete', docId);
                        showToast('Completion report analyzed!', 'success');
                        loadUsageStats(); // Refresh credits after processing complete
                    } else {
                        // Start polling for document status
                        completionProcessingStates[entryId] = {
                            ...completionProcessingStates[entryId],
                            status: docStatus === 'processing' ? 'processing' : 'queued',
                            documentId: docId,
                            pollStartTime: Date.now()
                        };
                        updateCompletionButtonState(currentBtn, docStatus === 'processing' ? 'processing' : 'queued');
                        startCompletionDocumentPolling(entryId, docId, getCurrentButton());
                    }
                } else if (result.error === 'no_credits') {
                    console.log(`[CompletionReports] No credits available`);
                    completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'idle' };
                    updateCompletionButtonState(currentBtn, 'idle');
                    showOutOfCreditsModal();
                } else {
                    throw new Error(result.message || result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('[CompletionReports] Error:', error);
                const currentBtn = getCurrentButton();
                completionProcessingStates[entryId] = { ...completionProcessingStates[entryId], status: 'error' };
                updateCompletionButtonState(currentBtn, 'error');
                showToast('Failed to analyze: ' + error.message, 'error');
            }
        }
        window.analyzeCompletion = analyzeCompletion;

        function startCompletionDocumentPolling(entryId, documentId, buttonEl) {
            const state = completionProcessingStates[entryId];
            if (!state || state.pollInterval) return; // Already polling

            console.log(`[CompletionReports Poll] Starting polling for ${documentId}`);

            state.pollInterval = setInterval(async () => {
                const currentState = completionProcessingStates[entryId];
                if (!currentState) {
                    clearInterval(state.pollInterval);
                    return;
                }

                // Always use the fresh button reference from state (it gets updated when DOM changes)
                const currentButtonEl = currentState.buttonEl;

                // Check if we've exceeded max poll duration
                if (Date.now() - currentState.pollStartTime > COMPLETION_MAX_POLL_DURATION) {
                    console.log(`[CompletionReports Poll] Max duration exceeded for ${documentId}`);
                    clearInterval(currentState.pollInterval);
                    currentState.pollInterval = null;
                    return;
                }

                try {
                    const response = await fetch(`/api/documents/${documentId}`, {
                        credentials: 'include'
                    });

                    if (!response.ok) {
                        console.log(`[CompletionReports Poll] Error fetching status for ${documentId}`);
                        return;
                    }

                    const data = await response.json();
                    const doc = data.document;

                    if (!doc) return;

                    console.log(`[CompletionReports Poll] Document ${documentId} status: ${doc.status}`);

                    if (doc.status === 'complete') {
                        // Document processing complete!
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'complete';
                        // Cache for future modal opens
                        analyzedCompletionsCache[entryId] = { documentId: documentId, displayName: doc.display_name };
                        updateCompletionButtonState(currentButtonEl, 'complete', documentId, doc.display_name);
                        showToast('Completion report analyzed!', 'success');
                        loadUsageStats(); // Refresh credits after processing complete
                    } else if (doc.status === 'processing' && currentState.status !== 'processing') {
                        // Transitioned to processing
                        currentState.status = 'processing';
                        updateCompletionButtonState(currentButtonEl, 'processing');
                    } else if (doc.status === 'failed' || doc.status === 'error') {
                        // Processing failed
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'error';
                        updateCompletionButtonState(currentButtonEl, 'error');
                        showToast('Document processing failed', 'error');
                    }
                } catch (err) {
                    console.error(`[CompletionReports Poll] Error polling ${documentId}:`, err);
                }
            }, COMPLETION_POLL_INTERVAL);
        }

        function updateCompletionButtonState(buttonEl, state, documentId = null, displayName = null) {
            if (!buttonEl) return;

            // Get parent container - this stays in the DOM even when we replace innerHTML
            let parentContainer = buttonEl.parentElement;
            let apiNum = buttonEl.dataset?.apiNumber || '';
            let entryId = buttonEl.dataset?.entryId || '';

            // If buttonEl is detached (parentElement is null), we can't update
            if (!parentContainer) {
                console.warn('[Completion] Button element is detached from DOM, cannot update state');
                return;
            }

            // For states that need a single button (not complete), replace container with completion-analyze-btn
            const createAnalyzeButton = (stateClass, disabled, innerHTML, title) => {
                parentContainer.innerHTML = `
                    <button class="completion-analyze-btn ${stateClass}"
                            data-api-number="${escapeHtml(apiNum)}"
                            data-entry-id="${escapeHtml(entryId)}"
                            ${disabled ? 'disabled' : ''}
                            onclick="analyzeCompletion('${escapeHtml(apiNum)}', ${entryId}, this)"
                            title="${title}">${innerHTML}</button>
                `;
                // Return the new button for reference updates
                return parentContainer.querySelector('button');
            };

            let newButton = null;
            switch (state) {
                case 'fetching':
                    newButton = createAnalyzeButton('fetching', true, '<span class="spinner-sm"></span> Fetching...', 'Downloading from OCC');
                    break;
                case 'queued':
                    newButton = createAnalyzeButton('queued', true, '<span class="spinner-sm"></span> Queued...', 'Waiting for processing');
                    break;
                case 'processing':
                    newButton = createAnalyzeButton('processing', true, '<span class="spinner-sm"></span> Processing...', 'Extracting document data');
                    break;
                case 'complete':
                    if (documentId) {
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    data-api-number="${escapeHtml(apiNum)}"
                                    data-entry-id="${escapeHtml(entryId)}"
                                    onclick="analyzeCompletion('${escapeHtml(apiNum)}', ${entryId}, this, true)"
                                    title="Re-process this document">Re-analyze</button>
                            <button class="occ-view-doc-btn"
                                    onclick="openDocumentDetail('${documentId}')"
                                    title="View analyzed document">View Doc ↗</button>
                        `;
                        newButton = parentContainer.querySelector('button');
                    } else {
                        newButton = createAnalyzeButton('analyzed', false, '✓ Analyzed', 'Analyzed');
                    }
                    break;
                case 'error':
                    newButton = createAnalyzeButton('error', false, 'Retry', 'Click to retry');
                    break;
                case 'idle':
                default:
                    newButton = createAnalyzeButton('', false, 'Analyze', 'Uses 1 document credit');
                    break;
            }

            // Update the state tracking with the new button reference
            if (entryId && completionProcessingStates[entryId] && newButton) {
                completionProcessingStates[entryId].buttonEl = newButton;
            }
        }

        // ============================================================================
        // Drilling Permits (Form 1000) Functions
        // ============================================================================

        const analyzedPermitsCache = {};

        function toggleDrillingPermits() {
            const content = document.getElementById('drilling-permits-content');
            const arrow = document.getElementById('drilling-permits-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }
        window.toggleDrillingPermits = toggleDrillingPermits;

        async function loadDrillingPermits(apiNumber) {
            console.log('[DrillingPermits] Loading permits for API:', apiNumber);
            const countBadge = document.getElementById('drilling-permits-count');
            const container = document.getElementById('drilling-permits-container');

            try {
                const response = await fetch(`/api/wells/${apiNumber}/drilling-permits`, {
                    credentials: 'include'
                });
                const data = await response.json();
                const permits = data.drillingPermits || [];

                console.log('[DrillingPermits] Loaded:', permits.length, 'permits');

                countBadge.className = '';
                countBadge.style.cssText = 'background: #e5e7eb; padding: 2px 8px; border-radius: 12px; font-size: 12px;';
                countBadge.textContent = permits.length;

                if (permits.length === 0) {
                    container.innerHTML = '<div style="color: #6b7280; font-size: 13px; font-style: italic; padding: 8px 0;">No drilling permits found</div>';
                    return;
                }

                // Sort by effective date (newest first)
                permits.sort((a, b) => {
                    const dateA = parseCompletionDate(a.effectiveDate);
                    const dateB = parseCompletionDate(b.effectiveDate);
                    return dateB - dateA;
                });

                // Populate cache for already-analyzed permits
                for (const permit of permits) {
                    if (permit.documentId && (permit.status === 'fetched' || permit.status === 'processed')) {
                        analyzedPermitsCache[permit.entryId] = { documentId: permit.documentId, displayName: permit.wellName };
                    }
                }

                container.innerHTML = permits.map((permit, idx) => renderDrillingPermit(permit, apiNumber, idx === 0)).join('');
            } catch (error) {
                console.error('[DrillingPermits] Error loading permits:', error);
                countBadge.className = '';
                countBadge.style.cssText = 'background: #fecaca; padding: 2px 8px; border-radius: 12px; font-size: 12px; color: #dc2626;';
                countBadge.textContent = '!';
                container.innerHTML = '<div style="color: #ef4444; font-size: 13px; padding: 8px 0;">Error loading drilling permits</div>';
            }
        }
        window.loadDrillingPermits = loadDrillingPermits;

        function renderDrillingPermit(permit, apiNumber, isCurrent = false) {
            const dateDisplay = formatCompletionDate(permit.effectiveDate);
            const buttonId = `permit-btn-${permit.entryId}`;
            const isFailed = permit.status === 'error';
            const currentBadge = isCurrent ? '<span class="completion-current-badge">Latest</span>' : '';
            const failedBadge = isFailed ? `<span class="completion-failed-badge" title="${escapeHtml(permit.errorMessage || 'Processing failed')}">Failed</span>` : '';

            const cached = analyzedPermitsCache[permit.entryId];

            let actionButton = '';
            if (cached && cached.documentId) {
                actionButton = `
                    <button class="occ-reanalyze-btn"
                            data-api-number="${apiNumber}"
                            data-entry-id="${permit.entryId}"
                            onclick="analyzePermit('${apiNumber}', ${permit.entryId}, this, true)"
                            title="Re-process this document">Re-analyze</button>
                    <button class="occ-view-doc-btn" onclick="openDocumentDetail('${cached.documentId}')" title="View analyzed document">View Doc ↗</button>`;
            } else switch (permit.status) {
                case 'available':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn"
                                data-api-number="${apiNumber}"
                                data-entry-id="${permit.entryId}"
                                onclick="analyzePermit('${apiNumber}', ${permit.entryId}, this)">
                            Analyze
                        </button>`;
                    break;
                case 'fetching':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn analyzing" disabled>
                            <span class="spinner-sm"></span>Analyzing...
                        </button>`;
                    break;
                case 'fetched':
                case 'processed':
                    actionButton = `
                        <button class="occ-reanalyze-btn"
                                data-api-number="${apiNumber}"
                                data-entry-id="${permit.entryId}"
                                onclick="analyzePermit('${apiNumber}', ${permit.entryId}, this, true)"
                                title="Re-process this document">Re-analyze</button>
                        ${permit.documentId ? `<button class="occ-view-doc-btn" onclick="openDocumentDetail('${permit.documentId}')" title="View analyzed document">View Doc ↗</button>` : ''}`;
                    break;
                case 'error':
                    actionButton = `
                        <button id="${buttonId}" class="completion-analyze-btn error"
                                onclick="analyzePermit('${apiNumber}', ${permit.entryId}, this, true)"
                                title="${escapeHtml(permit.errorMessage || 'Error occurred')}">
                            Retry
                        </button>`;
                    break;
                default:
                    actionButton = '<span style="color: #888; font-size: 12px;">—</span>';
            }

            return `
                <div class="completion-report-item${isCurrent ? ' is-current' : ''}${isFailed ? ' is-failed' : ''}">
                    <div class="completion-report-main">
                        <div>
                            <span class="completion-report-type" style="background: #DBEAFE; color: #1E40AF;">PERMIT 1000</span>
                            ${currentBadge}
                            ${failedBadge}
                            <span class="completion-report-location">${escapeHtml(permit.location || '')}</span>
                        </div>
                        <div class="completion-report-details">
                            ${permit.county ? `<span>${escapeHtml(permit.county)} County</span>` : ''}
                            ${permit.wellName ? `<span>• ${escapeHtml(permit.wellName)}</span>` : ''}
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
                        <div class="completion-report-date">${dateDisplay}</div>
                        <div class="occ-filing-actions">
                            ${actionButton}
                        </div>
                    </div>
                </div>
            `;
        }

        // Permit processing states (mirrors completion pattern)
        const permitProcessingStates = {};
        const PERMIT_POLL_INTERVAL = 5000;
        const PERMIT_MAX_POLL_DURATION = 5 * 60 * 1000;

        async function analyzePermit(apiNumber, entryId, buttonEl, force = false) {
            console.log(`[DrillingPermits] Analyzing ${apiNumber} entryId ${entryId}${force ? ' (force)' : ''}`);

            const getCurrentButton = () => permitProcessingStates[entryId]?.buttonEl || buttonEl;

            permitProcessingStates[entryId] = { status: 'fetching', buttonEl };
            updatePermitButtonState(buttonEl, 'fetching');

            try {
                const response = await fetch(`/api/wells/${apiNumber}/analyze-permit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ entryId, force })
                });

                const result = await response.json();
                const currentBtn = getCurrentButton();

                if (response.status === 401) {
                    permitProcessingStates[entryId] = { ...permitProcessingStates[entryId], status: 'idle' };
                    updatePermitButtonState(currentBtn, 'idle');
                    showToast('Please log in to analyze drilling permits', 'error');
                    return;
                }

                if (result.alreadyProcessed) {
                    console.log(`[DrillingPermits] Already processed: ${result.documentId}`);
                    permitProcessingStates[entryId] = { ...permitProcessingStates[entryId], status: 'complete', documentId: result.documentId };
                    updatePermitButtonState(currentBtn, 'complete', result.documentId, result.displayName);
                } else if (result.success) {
                    const docId = result.document.id;
                    const docStatus = result.document.status || 'pending';
                    console.log(`[DrillingPermits] Successfully queued: ${docId}, status: ${docStatus}`);

                    if (typeof updateCreditsDisplay === 'function') {
                        updateCreditsDisplay(result.creditsRemaining);
                    }

                    if (docStatus === 'complete') {
                        permitProcessingStates[entryId] = { ...permitProcessingStates[entryId], status: 'complete', documentId: docId };
                        analyzedPermitsCache[entryId] = { documentId: docId, displayName: result.document?.display_name };
                        updatePermitButtonState(currentBtn, 'complete', docId);
                        showToast('Drilling permit analyzed!', 'success');
                        loadUsageStats();
                    } else {
                        permitProcessingStates[entryId] = {
                            ...permitProcessingStates[entryId],
                            status: docStatus === 'processing' ? 'processing' : 'queued',
                            documentId: docId,
                            pollStartTime: Date.now()
                        };
                        updatePermitButtonState(currentBtn, docStatus === 'processing' ? 'processing' : 'queued');
                        startPermitDocumentPolling(entryId, docId, getCurrentButton());
                    }
                } else if (result.error === 'no_credits') {
                    console.log(`[DrillingPermits] No credits available`);
                    permitProcessingStates[entryId] = { ...permitProcessingStates[entryId], status: 'idle' };
                    updatePermitButtonState(currentBtn, 'idle');
                    showOutOfCreditsModal();
                } else {
                    throw new Error(result.message || result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('[DrillingPermits] Error:', error);
                const currentBtn = getCurrentButton();
                permitProcessingStates[entryId] = { ...permitProcessingStates[entryId], status: 'error' };
                updatePermitButtonState(currentBtn, 'error');
                showToast('Failed to analyze: ' + error.message, 'error');
            }
        }
        window.analyzePermit = analyzePermit;

        function startPermitDocumentPolling(entryId, documentId, buttonEl) {
            const state = permitProcessingStates[entryId];
            if (!state || state.pollInterval) return;

            console.log(`[DrillingPermits Poll] Starting polling for ${documentId}`);

            state.pollInterval = setInterval(async () => {
                const currentState = permitProcessingStates[entryId];
                if (!currentState) {
                    clearInterval(state.pollInterval);
                    return;
                }

                const currentButtonEl = currentState.buttonEl;

                if (Date.now() - currentState.pollStartTime > PERMIT_MAX_POLL_DURATION) {
                    console.log(`[DrillingPermits Poll] Max duration exceeded for ${documentId}`);
                    clearInterval(currentState.pollInterval);
                    currentState.pollInterval = null;
                    return;
                }

                try {
                    const response = await fetch(`/api/documents/${documentId}`, {
                        credentials: 'include'
                    });

                    if (!response.ok) return;

                    const data = await response.json();
                    const doc = data.document;
                    if (!doc) return;

                    console.log(`[DrillingPermits Poll] Document ${documentId} status: ${doc.status}`);

                    if (doc.status === 'complete') {
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'complete';
                        analyzedPermitsCache[entryId] = { documentId: documentId, displayName: doc.display_name };
                        updatePermitButtonState(currentButtonEl, 'complete', documentId, doc.display_name);
                        showToast('Drilling permit analyzed!', 'success');
                        loadUsageStats();
                    } else if (doc.status === 'processing' && currentState.status !== 'processing') {
                        currentState.status = 'processing';
                        updatePermitButtonState(currentButtonEl, 'processing');
                    } else if (doc.status === 'failed' || doc.status === 'error') {
                        clearInterval(currentState.pollInterval);
                        currentState.pollInterval = null;
                        currentState.status = 'error';
                        updatePermitButtonState(currentButtonEl, 'error');
                        showToast('Document processing failed', 'error');
                    }
                } catch (err) {
                    console.error(`[DrillingPermits Poll] Error polling ${documentId}:`, err);
                }
            }, PERMIT_POLL_INTERVAL);
        }

        function updatePermitButtonState(buttonEl, state, documentId = null, displayName = null) {
            if (!buttonEl) return;

            let parentContainer = buttonEl.parentElement;
            let apiNum = buttonEl.dataset?.apiNumber || '';
            let entryId = buttonEl.dataset?.entryId || '';

            if (!parentContainer) {
                console.warn('[Permit] Button element is detached from DOM');
                return;
            }

            const createBtn = (stateClass, disabled, innerHTML, title) => {
                parentContainer.innerHTML = `
                    <button class="completion-analyze-btn ${stateClass}"
                            data-api-number="${escapeHtml(apiNum)}"
                            data-entry-id="${escapeHtml(entryId)}"
                            ${disabled ? 'disabled' : ''}
                            onclick="analyzePermit('${escapeHtml(apiNum)}', ${entryId}, this)"
                            title="${title}">${innerHTML}</button>
                `;
                return parentContainer.querySelector('button');
            };

            let newButton = null;
            switch (state) {
                case 'fetching':
                    newButton = createBtn('fetching', true, '<span class="spinner-sm"></span> Fetching...', 'Downloading from OCC');
                    break;
                case 'queued':
                    newButton = createBtn('queued', true, '<span class="spinner-sm"></span> Queued...', 'Waiting for processing');
                    break;
                case 'processing':
                    newButton = createBtn('processing', true, '<span class="spinner-sm"></span> Processing...', 'Extracting document data');
                    break;
                case 'complete':
                    if (documentId) {
                        parentContainer.innerHTML = `
                            <button class="occ-reanalyze-btn"
                                    data-api-number="${escapeHtml(apiNum)}"
                                    data-entry-id="${escapeHtml(entryId)}"
                                    onclick="analyzePermit('${escapeHtml(apiNum)}', ${entryId}, this, true)"
                                    title="Re-process this document">Re-analyze</button>
                            <button class="occ-view-doc-btn"
                                    onclick="openDocumentDetail('${documentId}')"
                                    title="View analyzed document">View Doc ↗</button>
                        `;
                        newButton = parentContainer.querySelector('button');
                    } else {
                        newButton = createBtn('analyzed', false, '✓ Analyzed', 'Analyzed');
                    }
                    break;
                case 'error':
                    newButton = createBtn('error', false, 'Retry', 'Click to retry');
                    break;
                case 'idle':
                default:
                    newButton = createBtn('', false, 'Analyze', 'Uses 1 document credit');
                    break;
            }

            if (entryId && permitProcessingStates[entryId] && newButton) {
                permitProcessingStates[entryId].buttonEl = newButton;
            }
        }

        // OCC helpers (getOccStatusClass, formatOccDate, isOccHearingUpcoming,
        // formatCompletionDate, parseCompletionDate) are in shared-occ-helpers.txt
